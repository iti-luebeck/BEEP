
BEEP_XMega.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000bfc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00802000  00000bfc  00000c90  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000033  00802006  00802006  00000c96  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000c98  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  00001364  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  000013fb  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000108  00000000  00000000  0000142a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000289c  00000000  00000000  00001532  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000725  00000000  00000000  00003dce  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000007e7  00000000  00000000  000044f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000310  00000000  00000000  00004cdc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000012c0  00000000  00000000  00004fec  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000eb1  00000000  00000000  000062ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000120  00000000  00000000  0000715d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 ec 01 	jmp	0x3d8	; 0x3d8 <__ctors_end>
   4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
   8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
   c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  10:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  14:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  18:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  1c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  20:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  24:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  28:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  2c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  30:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  34:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  38:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  3c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  40:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  44:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  48:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  4c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  50:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  54:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  58:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  5c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  60:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  64:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  68:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  6c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  70:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  74:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  78:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  7c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  80:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  84:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  88:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  8c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  90:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  94:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  98:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  9c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  a0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  a4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  a8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  ac:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  b0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  b4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  b8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  bc:	0c 94 a0 04 	jmp	0x940	; 0x940 <__vector_47>
  c0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  c4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  c8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  cc:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  d0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  d4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  d8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  dc:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  e0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  e4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  e8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  ec:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  f0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  f4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  f8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  fc:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 100:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 104:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 108:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 10c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 110:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 114:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 118:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 11c:	0c 94 56 04 	jmp	0x8ac	; 0x8ac <__vector_71>
 120:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 124:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 128:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 12c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 130:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 134:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 138:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 13c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 140:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 144:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 148:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 14c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 150:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 154:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 158:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 15c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 160:	0c 94 02 04 	jmp	0x804	; 0x804 <__vector_88>
 164:	0c 94 2c 04 	jmp	0x858	; 0x858 <__vector_89>
 168:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 16c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 170:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 174:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 178:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 17c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 180:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 184:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 188:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 18c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 190:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 194:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 198:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 19c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1a0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1a4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1a8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1ac:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1b0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1b4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1b8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1bc:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1c0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1c4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>

000001c8 <ir_led_lut>:
 1c8:	00 01 02 03 05 06 07 04                             ........

000001d0 <rgb_led_lut>:
 1d0:	00 20 10 30 08 28 18 38                             . .0.(.8

000001d8 <pwmtable_12>:
 1d8:	00 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
 1e8:	01 00 01 00 01 00 01 00 02 00 02 00 02 00 02 00     ................
 1f8:	02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00     ................
 208:	02 00 02 00 02 00 02 00 03 00 03 00 03 00 03 00     ................
 218:	03 00 03 00 03 00 03 00 03 00 03 00 04 00 04 00     ................
 228:	04 00 04 00 04 00 04 00 04 00 04 00 05 00 05 00     ................
 238:	05 00 05 00 05 00 05 00 06 00 06 00 06 00 06 00     ................
 248:	06 00 07 00 07 00 07 00 07 00 07 00 08 00 08 00     ................
 258:	08 00 09 00 09 00 09 00 09 00 0a 00 0a 00 0a 00     ................
 268:	0b 00 0b 00 0b 00 0c 00 0c 00 0d 00 0d 00 0d 00     ................
 278:	0e 00 0e 00 0f 00 0f 00 10 00 10 00 11 00 11 00     ................
 288:	12 00 13 00 13 00 14 00 15 00 15 00 16 00 17 00     ................
 298:	17 00 18 00 19 00 1a 00 1b 00 1b 00 1c 00 1d 00     ................
 2a8:	1e 00 1f 00 20 00 21 00 23 00 24 00 25 00 26 00     .... .!.#.$.%.&.
 2b8:	27 00 29 00 2a 00 2b 00 2d 00 2e 00 30 00 31 00     '.).*.+.-...0.1.
 2c8:	33 00 35 00 36 00 38 00 3a 00 3c 00 3e 00 40 00     3.5.6.8.:.<.>.@.
 2d8:	42 00 44 00 47 00 49 00 4b 00 4e 00 50 00 53 00     B.D.G.I.K.N.P.S.
 2e8:	56 00 59 00 5b 00 5f 00 62 00 65 00 68 00 6c 00     V.Y.[._.b.e.h.l.
 2f8:	6f 00 73 00 77 00 7b 00 7f 00 83 00 87 00 8c 00     o.s.w.{.........
 308:	90 00 95 00 9a 00 9f 00 a4 00 aa 00 af 00 b5 00     ................
 318:	bb 00 c1 00 c8 00 ce 00 d5 00 dc 00 e3 00 eb 00     ................
 328:	f2 00 fa 00 03 01 0b 01 14 01 1d 01 27 01 30 01     ............'.0.
 338:	3a 01 45 01 50 01 5b 01 66 01 72 01 7e 01 8b 01     :.E.P.[.f.r.~...
 348:	98 01 a5 01 b3 01 c2 01 d0 01 e0 01 f0 01 00 02     ................
 358:	11 02 22 02 34 02 47 02 5a 02 6e 02 83 02 98 02     ..".4.G.Z.n.....
 368:	ae 02 c4 02 dc 02 f4 02 0d 03 27 03 41 03 5d 03     ..........'.A.].
 378:	79 03 97 03 b5 03 d4 03 f5 03 16 04 39 04 5c 04     y...........9.\.
 388:	81 04 a7 04 cf 04 f7 04 21 05 4d 05 7a 05 a8 05     ........!.M.z...
 398:	d8 05 09 06 3c 06 71 06 a7 06 df 06 1a 07 56 07     ....<.q.......V.
 3a8:	94 07 d4 07 16 08 5a 08 a1 08 ea 08 35 09 83 09     ......Z.....5...
 3b8:	d3 09 26 0a 7c 0a d5 0a 30 0b 8f 0b f1 0b 56 0c     ..&.|...0.....V.
 3c8:	be 0c 2a 0d 99 0d 0c 0e 83 0e fd 0e 7c 0f ff 0f     ..*.........|...

000003d8 <__ctors_end>:
 3d8:	11 24       	eor	r1, r1
 3da:	1f be       	out	0x3f, r1	; 63
 3dc:	cf ef       	ldi	r28, 0xFF	; 255
 3de:	df e2       	ldi	r29, 0x2F	; 47
 3e0:	de bf       	out	0x3e, r29	; 62
 3e2:	cd bf       	out	0x3d, r28	; 61

000003e4 <__do_copy_data>:
 3e4:	10 e2       	ldi	r17, 0x20	; 32
 3e6:	a0 e0       	ldi	r26, 0x00	; 0
 3e8:	b0 e2       	ldi	r27, 0x20	; 32
 3ea:	ec ef       	ldi	r30, 0xFC	; 252
 3ec:	fb e0       	ldi	r31, 0x0B	; 11
 3ee:	00 e0       	ldi	r16, 0x00	; 0
 3f0:	0b bf       	out	0x3b, r16	; 59
 3f2:	02 c0       	rjmp	.+4      	; 0x3f8 <__do_copy_data+0x14>
 3f4:	07 90       	elpm	r0, Z+
 3f6:	0d 92       	st	X+, r0
 3f8:	a6 30       	cpi	r26, 0x06	; 6
 3fa:	b1 07       	cpc	r27, r17
 3fc:	d9 f7       	brne	.-10     	; 0x3f4 <__do_copy_data+0x10>

000003fe <__do_clear_bss>:
 3fe:	20 e2       	ldi	r18, 0x20	; 32
 400:	a6 e0       	ldi	r26, 0x06	; 6
 402:	b0 e2       	ldi	r27, 0x20	; 32
 404:	01 c0       	rjmp	.+2      	; 0x408 <.do_clear_bss_start>

00000406 <.do_clear_bss_loop>:
 406:	1d 92       	st	X+, r1

00000408 <.do_clear_bss_start>:
 408:	a9 33       	cpi	r26, 0x39	; 57
 40a:	b2 07       	cpc	r27, r18
 40c:	e1 f7       	brne	.-8      	; 0x406 <.do_clear_bss_loop>
 40e:	0e 94 b0 02 	call	0x560	; 0x560 <main>
 412:	0c 94 fc 05 	jmp	0xbf8	; 0xbf8 <_exit>

00000416 <__bad_interrupt>:
 416:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000041a <init_enable_32mhz>:




void init_enable_32mhz(void){
		OSC.CTRL |= OSC_RC32MEN_bm; //Enable 32 Mhz oscillator
 41a:	e0 e5       	ldi	r30, 0x50	; 80
 41c:	f0 e0       	ldi	r31, 0x00	; 0
 41e:	80 81       	ld	r24, Z
 420:	82 60       	ori	r24, 0x02	; 2
 422:	80 83       	st	Z, r24
		while(!(OSC.STATUS & OSC_RC32MRDY_bm)); //Wait until 32 Mhz oscillator is ready
 424:	81 81       	ldd	r24, Z+1	; 0x01
 426:	81 ff       	sbrs	r24, 1
 428:	fd cf       	rjmp	.-6      	; 0x424 <init_enable_32mhz+0xa>
		CCP = CCP_IOREG_gc; //Disable configuration change protection for four cycles
 42a:	88 ed       	ldi	r24, 0xD8	; 216
 42c:	84 bf       	out	0x34, r24	; 52
		CLK.CTRL = CLK_SCLKSEL_RC32M_gc; //Set 32Mhz as main clock
 42e:	81 e0       	ldi	r24, 0x01	; 1
 430:	80 93 40 00 	sts	0x0040, r24
		OSC.CTRL &= ~OSC_RC2MEN_bm; //Disable 2 Mhz oscillator
 434:	e0 e5       	ldi	r30, 0x50	; 80
 436:	f0 e0       	ldi	r31, 0x00	; 0
 438:	80 81       	ld	r24, Z
 43a:	8e 7f       	andi	r24, 0xFE	; 254
 43c:	80 83       	st	Z, r24
 43e:	08 95       	ret

00000440 <init_usart>:
}

void init_usart(void){
 440:	cf 93       	push	r28
 442:	df 93       	push	r29
	// Output TX
	PORTD.DIRSET = PIN3_bm;
 444:	e0 e6       	ldi	r30, 0x60	; 96
 446:	f6 e0       	ldi	r31, 0x06	; 6
 448:	88 e0       	ldi	r24, 0x08	; 8
 44a:	81 83       	std	Z+1, r24	; 0x01
	// Input RX
	PORTD.DIRCLR = PIN2_bm;
 44c:	84 e0       	ldi	r24, 0x04	; 4
 44e:	82 83       	std	Z+2, r24	; 0x02
	
	// init Buffers using USARTD0
	USART_InterruptDriver_Initialize(&USART_data, &USARTD0, USART_DREINTLVL_LO_gc);
 450:	41 e0       	ldi	r20, 0x01	; 1
 452:	60 ea       	ldi	r22, 0xA0	; 160
 454:	79 e0       	ldi	r23, 0x09	; 9
 456:	8a e2       	ldi	r24, 0x2A	; 42
 458:	90 e2       	ldi	r25, 0x20	; 32
 45a:	0e 94 68 05 	call	0xad0	; 0xad0 <USART_InterruptDriver_Initialize>
	
	/* USARTD0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(USART_data.usart, USART_CHSIZE_8BIT_gc,
 45e:	c0 91 2a 20 	lds	r28, 0x202A
 462:	d0 91 2b 20 	lds	r29, 0x202B
 466:	83 e0       	ldi	r24, 0x03	; 3
 468:	8d 83       	std	Y+5, r24	; 0x05
                     USART_PMODE_DISABLED_gc, false);

	/* Enable RXC interrupt. */
	USART_RxdInterruptLevel_Set(USART_data.usart, USART_RXCINTLVL_LO_gc);
 46a:	8b 81       	ldd	r24, Y+3	; 0x03
 46c:	8f 7c       	andi	r24, 0xCF	; 207
 46e:	80 61       	ori	r24, 0x10	; 16
 470:	8b 83       	std	Y+3, r24	; 0x03
	/* Set Baudrate to 9600 bps:
	 * Do not use the baudrate scale factor
	 * Baudrate ((I/O clock frequency)/(2^(ScaleFactor)*16*Baudrate))-1
	 */
	
	USART_Baudrate_Set(&USARTD0, ((F_CPU/(16*baudrate))-1) , 0);
 472:	80 91 01 20 	lds	r24, 0x2001
 476:	90 91 02 20 	lds	r25, 0x2002
 47a:	a0 91 03 20 	lds	r26, 0x2003
 47e:	b0 91 04 20 	lds	r27, 0x2004
 482:	88 0f       	add	r24, r24
 484:	99 1f       	adc	r25, r25
 486:	aa 1f       	adc	r26, r26
 488:	bb 1f       	adc	r27, r27
 48a:	88 0f       	add	r24, r24
 48c:	99 1f       	adc	r25, r25
 48e:	aa 1f       	adc	r26, r26
 490:	bb 1f       	adc	r27, r27
 492:	9c 01       	movw	r18, r24
 494:	ad 01       	movw	r20, r26
 496:	22 0f       	add	r18, r18
 498:	33 1f       	adc	r19, r19
 49a:	44 1f       	adc	r20, r20
 49c:	55 1f       	adc	r21, r21
 49e:	22 0f       	add	r18, r18
 4a0:	33 1f       	adc	r19, r19
 4a2:	44 1f       	adc	r20, r20
 4a4:	55 1f       	adc	r21, r21
 4a6:	60 e0       	ldi	r22, 0x00	; 0
 4a8:	78 e4       	ldi	r23, 0x48	; 72
 4aa:	88 ee       	ldi	r24, 0xE8	; 232
 4ac:	91 e0       	ldi	r25, 0x01	; 1
 4ae:	0e 94 da 05 	call	0xbb4	; 0xbb4 <__udivmodsi4>
 4b2:	82 2f       	mov	r24, r18
 4b4:	81 50       	subi	r24, 0x01	; 1
 4b6:	e0 ea       	ldi	r30, 0xA0	; 160
 4b8:	f9 e0       	ldi	r31, 0x09	; 9
 4ba:	86 83       	std	Z+6, r24	; 0x06
 4bc:	da 01       	movw	r26, r20
 4be:	c9 01       	movw	r24, r18
 4c0:	01 97       	sbiw	r24, 0x01	; 1
 4c2:	a1 09       	sbc	r26, r1
 4c4:	b1 09       	sbc	r27, r1
 4c6:	89 2f       	mov	r24, r25
 4c8:	9a 2f       	mov	r25, r26
 4ca:	ab 2f       	mov	r26, r27
 4cc:	bb 27       	eor	r27, r27
 4ce:	87 83       	std	Z+7, r24	; 0x07
	
	//USART_Baudrate_Set(&USARTD0, 1/(16*((F_CPU/baudrate)-1)) , 0);

	/* Enable both RX and TX. */
	USART_Rx_Enable(USART_data.usart);
 4d0:	8c 81       	ldd	r24, Y+4	; 0x04
 4d2:	80 61       	ori	r24, 0x10	; 16
 4d4:	8c 83       	std	Y+4, r24	; 0x04
	USART_Tx_Enable(USART_data.usart);
 4d6:	8c 81       	ldd	r24, Y+4	; 0x04
 4d8:	88 60       	ori	r24, 0x08	; 8
 4da:	8c 83       	std	Y+4, r24	; 0x04
}
 4dc:	df 91       	pop	r29
 4de:	cf 91       	pop	r28
 4e0:	08 95       	ret

000004e2 <init_adc>:


void init_adc(void){
	ADCA.CTRLA = ADC_ENABLE_bm; //enable adc
 4e2:	e0 e0       	ldi	r30, 0x00	; 0
 4e4:	f2 e0       	ldi	r31, 0x02	; 2
 4e6:	81 e0       	ldi	r24, 0x01	; 1
 4e8:	80 83       	st	Z, r24
	ADCA.CTRLB = ADC_CONMODE_bm | ADC_RESOLUTION_12BIT_gc; //signed mode, no current limit, no freerun, 12 bit resolution
 4ea:	90 e1       	ldi	r25, 0x10	; 16
 4ec:	91 83       	std	Z+1, r25	; 0x01
	ADCA.PRESCALER = ADC_PRESCALER_DIV128_gc; //Set 32 clock devider
 4ee:	95 e0       	ldi	r25, 0x05	; 5
 4f0:	94 83       	std	Z+4, r25	; 0x04
	ADCA.REFCTRL = ADC_REFSEL_INT1V_gc; // use inernal 1V ref
 4f2:	12 82       	std	Z+2, r1	; 0x02
	
	ADCA.CH0.INTCTRL = ADC_CH_INTMODE_COMPLETE_gc|ADC_CH_INTLVL_LO_gc; //low priority interrupt on conv complete
 4f4:	82 a3       	std	Z+34, r24	; 0x22
 4f6:	08 95       	ret

000004f8 <start_adc>:



void start_adc(uint8_t input){
	//input between 0 and 15
	ADCA.CH0.MUXCTRL = (input<<3) | ADC_CH_MUXNEG_PIN1_gc; //setup mux: input channel | refference voltage
 4f8:	28 e0       	ldi	r18, 0x08	; 8
 4fa:	82 9f       	mul	r24, r18
 4fc:	c0 01       	movw	r24, r0
 4fe:	11 24       	eor	r1, r1
 500:	81 60       	ori	r24, 0x01	; 1
 502:	e0 e0       	ldi	r30, 0x00	; 0
 504:	f2 e0       	ldi	r31, 0x02	; 2
 506:	81 a3       	std	Z+33, r24	; 0x21
	ADCA.CH0.CTRL = ADC_CH_START_bm | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_DIFF_gc; //start conv with 1x gain, diff mode
 508:	82 e8       	ldi	r24, 0x82	; 130
 50a:	80 a3       	std	Z+32, r24	; 0x20
 50c:	08 95       	ret

0000050e <set_beepmotor_speed>:
}



void set_beepmotor_speed(motor_t motor, int8_t speed){
 50e:	cf 93       	push	r28
 510:	df 93       	push	r29
 512:	c8 2f       	mov	r28, r24
 514:	d6 2f       	mov	r29, r22
	motor_op_mode_t op = motor_stop;
	
	if (speed<0){
 516:	66 23       	and	r22, r22
 518:	5c f4       	brge	.+22     	; 0x530 <set_beepmotor_speed+0x22>
		if(speed == INT8_MIN){
 51a:	60 38       	cpi	r22, 0x80	; 128
 51c:	11 f0       	breq	.+4      	; 0x522 <set_beepmotor_speed+0x14>
			speed = INT8_MAX;
		}else{
			speed = -speed;
 51e:	d1 95       	neg	r29
 520:	01 c0       	rjmp	.+2      	; 0x524 <set_beepmotor_speed+0x16>
void set_beepmotor_speed(motor_t motor, int8_t speed){
	motor_op_mode_t op = motor_stop;
	
	if (speed<0){
		if(speed == INT8_MIN){
			speed = INT8_MAX;
 522:	df e7       	ldi	r29, 0x7F	; 127
		}else{
			speed = -speed;
		}		
		if(motor == motor_l){
 524:	c4 30       	cpi	r28, 0x04	; 4
 526:	51 f0       	breq	.+20     	; 0x53c <set_beepmotor_speed+0x2e>
			op = motor_cw;
		}else if(motor == motor_r){
 528:	c6 30       	cpi	r28, 0x06	; 6
 52a:	51 f0       	breq	.+20     	; 0x540 <set_beepmotor_speed+0x32>
}



void set_beepmotor_speed(motor_t motor, int8_t speed){
	motor_op_mode_t op = motor_stop;
 52c:	63 e0       	ldi	r22, 0x03	; 3
 52e:	0d c0       	rjmp	.+26     	; 0x54a <set_beepmotor_speed+0x3c>
			op = motor_cw;
		}else if(motor == motor_r){
			op = motor_ccw;
		}
	}else{
		if(motor == motor_l){
 530:	84 30       	cpi	r24, 0x04	; 4
 532:	41 f0       	breq	.+16     	; 0x544 <set_beepmotor_speed+0x36>
			op = motor_ccw;
			}else if(motor == motor_r){
 534:	86 30       	cpi	r24, 0x06	; 6
 536:	41 f0       	breq	.+16     	; 0x548 <set_beepmotor_speed+0x3a>
}



void set_beepmotor_speed(motor_t motor, int8_t speed){
	motor_op_mode_t op = motor_stop;
 538:	63 e0       	ldi	r22, 0x03	; 3
 53a:	07 c0       	rjmp	.+14     	; 0x54a <set_beepmotor_speed+0x3c>
			speed = INT8_MAX;
		}else{
			speed = -speed;
		}		
		if(motor == motor_l){
			op = motor_cw;
 53c:	61 e0       	ldi	r22, 0x01	; 1
 53e:	05 c0       	rjmp	.+10     	; 0x54a <set_beepmotor_speed+0x3c>
		}else if(motor == motor_r){
			op = motor_ccw;
 540:	62 e0       	ldi	r22, 0x02	; 2
 542:	03 c0       	rjmp	.+6      	; 0x54a <set_beepmotor_speed+0x3c>
		}
	}else{
		if(motor == motor_l){
			op = motor_ccw;
 544:	62 e0       	ldi	r22, 0x02	; 2
 546:	01 c0       	rjmp	.+2      	; 0x54a <set_beepmotor_speed+0x3c>
			}else if(motor == motor_r){
			op = motor_cw;
 548:	61 e0       	ldi	r22, 0x01	; 1
		}
	}
	uint8_t new_speed = speed * (UINT8_MAX / INT8_MAX);
	set_motor_operation_mode(motor, op);
 54a:	8c 2f       	mov	r24, r28
 54c:	0e 94 1e 05 	call	0xa3c	; 0xa3c <set_motor_operation_mode>
			op = motor_ccw;
			}else if(motor == motor_r){
			op = motor_cw;
		}
	}
	uint8_t new_speed = speed * (UINT8_MAX / INT8_MAX);
 550:	6d 2f       	mov	r22, r29
 552:	66 0f       	add	r22, r22
	set_motor_operation_mode(motor, op);
	set_motor_speed(motor, new_speed);
 554:	8c 2f       	mov	r24, r28
 556:	0e 94 49 05 	call	0xa92	; 0xa92 <set_motor_speed>
	
}
 55a:	df 91       	pop	r29
 55c:	cf 91       	pop	r28
 55e:	08 95       	ret

00000560 <main>:

const uint8_t ir_led_lut[8] PROGMEM = {
0b000,0b001,0b010,0b011,0b101,0b110,0b111,0b100};


int main(void){
 560:	cf 93       	push	r28
 562:	df 93       	push	r29
 564:	cd b7       	in	r28, 0x3d	; 61
 566:	de b7       	in	r29, 0x3e	; 62
 568:	28 97       	sbiw	r28, 0x08	; 8
 56a:	cd bf       	out	0x3d, r28	; 61
 56c:	de bf       	out	0x3e, r29	; 62
	
	init_enable_32mhz();
 56e:	0e 94 0d 02 	call	0x41a	; 0x41a <init_enable_32mhz>
	init_usart();
 572:	0e 94 20 02 	call	0x440	; 0x440 <init_usart>
	init_motor();
 576:	0e 94 32 05 	call	0xa64	; 0xa64 <init_motor>
	init_adc();
 57a:	0e 94 71 02 	call	0x4e2	; 0x4e2 <init_adc>
	//TODO decide about priorities
	
}

inline void init_rgb_led(void){
	PORTF.DIRSET = PIN3_bm | PIN4_bm | PIN5_bm; //LED multiplexer Pins as output
 57e:	a0 ea       	ldi	r26, 0xA0	; 160
 580:	b6 e0       	ldi	r27, 0x06	; 6
 582:	88 e3       	ldi	r24, 0x38	; 56
 584:	11 96       	adiw	r26, 0x01	; 1
 586:	8c 93       	st	X, r24
 588:	11 97       	sbiw	r26, 0x01	; 1
	PORTE.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm; //Set LED PWM as output
 58a:	e0 e8       	ldi	r30, 0x80	; 128
 58c:	f6 e0       	ldi	r31, 0x06	; 6
 58e:	27 e0       	ldi	r18, 0x07	; 7
 590:	21 83       	std	Z+1, r18	; 0x01
	PORTE.PIN0CTRL |= PORT_INVEN_bm; //Invert PWM Channels for NAND driver
 592:	80 89       	ldd	r24, Z+16	; 0x10
 594:	80 64       	ori	r24, 0x40	; 64
 596:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL |= PORT_INVEN_bm;
 598:	81 89       	ldd	r24, Z+17	; 0x11
 59a:	80 64       	ori	r24, 0x40	; 64
 59c:	81 8b       	std	Z+17, r24	; 0x11
	PORTE.PIN2CTRL |= PORT_INVEN_bm;
 59e:	82 89       	ldd	r24, Z+18	; 0x12
 5a0:	80 64       	ori	r24, 0x40	; 64
 5a2:	82 8b       	std	Z+18, r24	; 0x12

	TCE0.CTRLB = PWM_RED_ENABLE_gc|PWM_GREEN_ENABLE_gc|PWM_BLUE_ENABLE_gc| TC_WGMODE_SS_gc; //enable pwm output, Single slope pwm
 5a4:	e0 e0       	ldi	r30, 0x00	; 0
 5a6:	fa e0       	ldi	r31, 0x0A	; 10
 5a8:	83 e7       	ldi	r24, 0x73	; 115
 5aa:	81 83       	std	Z+1, r24	; 0x01
	
	TCE0.PER = 0xfff; //12 Bit resolution per period
 5ac:	8f ef       	ldi	r24, 0xFF	; 255
 5ae:	9f e0       	ldi	r25, 0x0F	; 15
 5b0:	86 a3       	std	Z+38, r24	; 0x26
 5b2:	97 a3       	std	Z+39, r25	; 0x27
	
	//Enable overflow interrupt for Timer 0 on Port C to swich rgb LED
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
 5b4:	81 e0       	ldi	r24, 0x01	; 1
 5b6:	86 83       	std	Z+6, r24	; 0x06


inline void enable_rgb_leds(bool enable){
	if (enable){
		//reset counter
		TCE0.CNT = 0x00;
 5b8:	10 a2       	std	Z+32, r1	; 0x20
 5ba:	11 a2       	std	Z+33, r1	; 0x21
		//restart counter
		TCE0.CTRLA = TC_CLKSEL_DIV1_gc;
 5bc:	80 83       	st	Z, r24
	init_rgb_led();
	enable_rgb_leds(true);
	

	/* Enable PMIC interrupt level low. */
	PMIC.CTRL |= PMIC_LOLVLEX_bm;
 5be:	e0 ea       	ldi	r30, 0xA0	; 160
 5c0:	f0 e0       	ldi	r31, 0x00	; 0
 5c2:	82 81       	ldd	r24, Z+2	; 0x02
 5c4:	81 60       	ori	r24, 0x01	; 1
 5c6:	82 83       	std	Z+2, r24	; 0x02

	/* Enable global interrupts. */
	sei();
 5c8:	78 94       	sei

	// set some colors
	myColors[0].red = 0x00;
 5ca:	10 92 09 20 	sts	0x2009, r1
	myColors[0].green = 0x00;
 5ce:	10 92 0a 20 	sts	0x200A, r1
	myColors[0].blue = 0x00;
 5d2:	10 92 0b 20 	sts	0x200B, r1
	
	myColors[1].red = 0x00;
 5d6:	10 92 0c 20 	sts	0x200C, r1
	myColors[1].green = 0xaf;
 5da:	8f ea       	ldi	r24, 0xAF	; 175
 5dc:	80 93 0d 20 	sts	0x200D, r24
	myColors[1].blue = 0x00;
 5e0:	10 92 0e 20 	sts	0x200E, r1
	
	myColors[2].red = 0xaf;
 5e4:	80 93 0f 20 	sts	0x200F, r24
	myColors[2].green = 0x00;
 5e8:	10 92 10 20 	sts	0x2010, r1
	myColors[2].blue = 0x00;
 5ec:	10 92 11 20 	sts	0x2011, r1
	
	myColors[3].red = 0x00;
 5f0:	10 92 12 20 	sts	0x2012, r1
	myColors[3].green = 0x00;
 5f4:	10 92 13 20 	sts	0x2013, r1
	myColors[3].blue = 0x00;
 5f8:	10 92 14 20 	sts	0x2014, r1
	
	myColors[4].red = 0x00;
 5fc:	10 92 15 20 	sts	0x2015, r1
	myColors[4].green = 0x00;
 600:	10 92 16 20 	sts	0x2016, r1
	myColors[4].blue = 0x00;
 604:	10 92 17 20 	sts	0x2017, r1
	
	myColors[5].red = 0xaf;
 608:	80 93 18 20 	sts	0x2018, r24
	myColors[5].green = 0xaf;
 60c:	80 93 19 20 	sts	0x2019, r24
	myColors[5].blue = 0x00;
 610:	10 92 1a 20 	sts	0x201A, r1
	
	myColors[6].red = 0xaf;
 614:	80 93 1b 20 	sts	0x201B, r24
	myColors[6].green = 0x00;
 618:	10 92 1c 20 	sts	0x201C, r1
	myColors[6].blue = 0xaf;
 61c:	80 93 1d 20 	sts	0x201D, r24
	
	myColors[7].red = 0x00;
 620:	10 92 1e 20 	sts	0x201E, r1
	myColors[7].green = 0x00;
 624:	10 92 1f 20 	sts	0x201F, r1
	myColors[7].blue = 0x00;
 628:	10 92 20 20 	sts	0x2020, r1
	next_command.head = 0;
	next_command.command = 0;
	next_command.device = 0;
	
	//TEMP IR LED TEST
	PORTF.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;
 62c:	11 96       	adiw	r26, 0x01	; 1
 62e:	2c 93       	st	X, r18
 630:	11 97       	sbiw	r26, 0x01	; 1
	PORTF.OUTSET = pgm_read_word(&ir_led_lut[2]);;
 632:	ea ec       	ldi	r30, 0xCA	; 202
 634:	f1 e0       	ldi	r31, 0x01	; 1
 636:	85 91       	lpm	r24, Z+
 638:	94 91       	lpm	r25, Z
 63a:	15 96       	adiw	r26, 0x05	; 5
 63c:	8c 93       	st	X, r24
	
	set_motor_on(false);
 63e:	80 e0       	ldi	r24, 0x00	; 0
 640:	0e 94 5c 05 	call	0xab8	; 0xab8 <set_motor_on>
	set_beepmotor_speed(motor_r, 50);
 644:	62 e3       	ldi	r22, 0x32	; 50
 646:	86 e0       	ldi	r24, 0x06	; 6
 648:	0e 94 87 02 	call	0x50e	; 0x50e <set_beepmotor_speed>
	set_beepmotor_speed(motor_l, -50);
 64c:	6e ec       	ldi	r22, 0xCE	; 206
 64e:	84 e0       	ldi	r24, 0x04	; 4
 650:	0e 94 87 02 	call	0x50e	; 0x50e <set_beepmotor_speed>

	Command_Buffer_t next_command;
	next_command.data_missing =- 1;
	next_command.head = 0;
	next_command.command = 0;
	next_command.device = 0;
 654:	00 e0       	ldi	r16, 0x00	; 0
	// TODO Interrupts erst später aktivieren

	Command_Buffer_t next_command;
	next_command.data_missing =- 1;
	next_command.head = 0;
	next_command.command = 0;
 656:	b1 2c       	mov	r11, r1
	//set_motor_on(true);
	// TODO Interrupts erst später aktivieren

	Command_Buffer_t next_command;
	next_command.data_missing =- 1;
	next_command.head = 0;
 658:	a1 2c       	mov	r10, r1
	
	//set_motor_on(true);
	// TODO Interrupts erst später aktivieren

	Command_Buffer_t next_command;
	next_command.data_missing =- 1;
 65a:	1f ef       	ldi	r17, 0xFF	; 255
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
						next_command.data_missing =- 1;
 65c:	dd 24       	eor	r13, r13
 65e:	da 94       	dec	r13


inline void enable_rgb_leds(bool enable){
	if (enable){
		//reset counter
		TCE0.CNT = 0x00;
 660:	0f 2e       	mov	r0, r31
 662:	e1 2c       	mov	r14, r1
 664:	fa e0       	ldi	r31, 0x0A	; 10
 666:	ff 2e       	mov	r15, r31
 668:	f0 2d       	mov	r31, r0
		//restart counter
		TCE0.CTRLA = TC_CLKSEL_DIV1_gc;
 66a:	cc 24       	eor	r12, r12
 66c:	c3 94       	inc	r12
	}else{
		TCE0.CTRLA = 0; // disable pwm output
		PORTE.OUTCLR = PIN0_bm | PIN1_bm | PIN2_bm; // clear outputs
 66e:	0f 2e       	mov	r0, r31
 670:	f0 e8       	ldi	r31, 0x80	; 128
 672:	6f 2e       	mov	r6, r31
 674:	f6 e0       	ldi	r31, 0x06	; 6
 676:	7f 2e       	mov	r7, r31
 678:	f0 2d       	mov	r31, r0
 67a:	0f 2e       	mov	r0, r31
 67c:	f7 e0       	ldi	r31, 0x07	; 7
 67e:	8f 2e       	mov	r8, r31
 680:	f0 2d       	mov	r31, r0
						if(next_command.command <= 7){
							conv_left = 1;
							direct_send_adc_res = true;
							start_adc(next_command.command);
						}else if (next_command.command == beep_com_ir_all){							
							conv_left = 8;
 682:	68 94       	set
 684:	99 24       	eor	r9, r9
 686:	93 f8       	bld	r9, 3
 688:	10 c0       	rjmp	.+32     	; 0x6aa <main+0x14a>
					next_command.device = data & beep_dev_mask;
					next_command.command = data & beep_command_mask;
					//get number of missing data to execute command
					if(next_command.device == beep_dev_motors){
						if(next_command.command == beep_com_left_motor){
							next_command.data_missing = 1;
 68a:	1c 2d       	mov	r17, r12
 68c:	0e c0       	rjmp	.+28     	; 0x6aa <main+0x14a>
						}else if (next_command.command == beep_com_right_motor){
							next_command.data_missing = 1;
 68e:	1c 2d       	mov	r17, r12
 690:	0c c0       	rjmp	.+24     	; 0x6aa <main+0x14a>
						}else if (next_command.command == beep_com_both_motors){
							next_command.data_missing = 2;
 692:	12 e0       	ldi	r17, 0x02	; 2
 694:	0a c0       	rjmp	.+20     	; 0x6aa <main+0x14a>
						if(next_command.command == BEEP_COM_LEDS_OFF){
							enable_rgb_leds(false);
						}else if(next_command.command == BEEP_COM_LEDS_ON){
							enable_rgb_leds(true);
						}else if(next_command.command < 8){
							next_command.data_missing = 3;
 696:	13 e0       	ldi	r17, 0x03	; 3
 698:	08 c0       	rjmp	.+16     	; 0x6aa <main+0x14a>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 69a:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 69c:	1d 2d       	mov	r17, r13
 69e:	05 c0       	rjmp	.+10     	; 0x6aa <main+0x14a>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 6a0:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 6a2:	1d 2d       	mov	r17, r13
 6a4:	02 c0       	rjmp	.+4      	; 0x6aa <main+0x14a>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 6a6:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 6a8:	1d 2d       	mov	r17, r13
	set_beepmotor_speed(motor_r, 50);
	set_beepmotor_speed(motor_l, -50);
	
	
    while(1){		
		if(conv_left == 0){
 6aa:	80 91 06 20 	lds	r24, 0x2006
 6ae:	81 11       	cpse	r24, r1
 6b0:	fc cf       	rjmp	.-8      	; 0x6aa <main+0x14a>
			if(USART_RXBufferData_Available(&USART_data)){
 6b2:	8a e2       	ldi	r24, 0x2A	; 42
 6b4:	90 e2       	ldi	r25, 0x20	; 32
 6b6:	0e 94 97 05 	call	0xb2e	; 0xb2e <USART_RXBufferData_Available>
 6ba:	88 23       	and	r24, r24
 6bc:	b1 f3       	breq	.-20     	; 0x6aa <main+0x14a>
				uint8_t data = USART_RXBuffer_GetByte(&USART_data);
 6be:	8a e2       	ldi	r24, 0x2A	; 42
 6c0:	90 e2       	ldi	r25, 0x20	; 32
 6c2:	0e 94 9f 05 	call	0xb3e	; 0xb3e <USART_RXBuffer_GetByte>
				if(next_command.data_missing == -1){
 6c6:	1f 3f       	cpi	r17, 0xFF	; 255
 6c8:	09 f0       	breq	.+2      	; 0x6cc <main+0x16c>
 6ca:	53 c0       	rjmp	.+166    	; 0x772 <main+0x212>
					next_command.device = data & beep_dev_mask;
 6cc:	08 2f       	mov	r16, r24
 6ce:	00 7f       	andi	r16, 0xF0	; 240
					next_command.command = data & beep_command_mask;
 6d0:	0f 2e       	mov	r0, r31
 6d2:	ff e0       	ldi	r31, 0x0F	; 15
 6d4:	bf 2e       	mov	r11, r31
 6d6:	f0 2d       	mov	r31, r0
 6d8:	b8 22       	and	r11, r24
					//get number of missing data to execute command
					if(next_command.device == beep_dev_motors){
 6da:	00 34       	cpi	r16, 0x40	; 64
 6dc:	b9 f4       	brne	.+46     	; 0x70c <main+0x1ac>
						if(next_command.command == beep_com_left_motor){
 6de:	81 e0       	ldi	r24, 0x01	; 1
 6e0:	b8 16       	cp	r11, r24
 6e2:	99 f2       	breq	.-90     	; 0x68a <main+0x12a>
							next_command.data_missing = 1;
						}else if (next_command.command == beep_com_right_motor){
 6e4:	e2 e0       	ldi	r30, 0x02	; 2
 6e6:	be 16       	cp	r11, r30
 6e8:	91 f2       	breq	.-92     	; 0x68e <main+0x12e>
							next_command.data_missing = 1;
						}else if (next_command.command == beep_com_both_motors){
 6ea:	f3 e0       	ldi	r31, 0x03	; 3
 6ec:	bf 16       	cp	r11, r31
 6ee:	89 f2       	breq	.-94     	; 0x692 <main+0x132>
							next_command.data_missing = 2;
						}else if (next_command.command == beep_com_motor_enable){
 6f0:	8e e0       	ldi	r24, 0x0E	; 14
 6f2:	b8 12       	cpse	r11, r24
 6f4:	04 c0       	rjmp	.+8      	; 0x6fe <main+0x19e>
							set_motor_on(true);
 6f6:	8c 2d       	mov	r24, r12
 6f8:	0e 94 5c 05 	call	0xab8	; 0xab8 <set_motor_on>
 6fc:	d6 cf       	rjmp	.-84     	; 0x6aa <main+0x14a>
							//next_command.data_missing = -1;
						}else if (next_command.command == beep_com_motor_shutdown){
 6fe:	ef e0       	ldi	r30, 0x0F	; 15
 700:	be 12       	cpse	r11, r30
 702:	d3 cf       	rjmp	.-90     	; 0x6aa <main+0x14a>
							set_motor_on(false);
 704:	80 e0       	ldi	r24, 0x00	; 0
 706:	0e 94 5c 05 	call	0xab8	; 0xab8 <set_motor_on>
 70a:	cf cf       	rjmp	.-98     	; 0x6aa <main+0x14a>
							//next_command.data_missing = -1;
						}
					}else if(next_command.device == beep_dev_ir){			
 70c:	01 11       	cpse	r16, r1
 70e:	19 c0       	rjmp	.+50     	; 0x742 <main+0x1e2>
						if(next_command.command <= 7){
 710:	f7 e0       	ldi	r31, 0x07	; 7
 712:	fb 15       	cp	r31, r11
 714:	40 f0       	brcs	.+16     	; 0x726 <main+0x1c6>
							conv_left = 1;
 716:	c0 92 06 20 	sts	0x2006, r12
							direct_send_adc_res = true;
 71a:	c0 92 00 20 	sts	0x2000, r12
							start_adc(next_command.command);
 71e:	8b 2d       	mov	r24, r11
 720:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <start_adc>
 724:	c2 cf       	rjmp	.-124    	; 0x6aa <main+0x14a>
						}else if (next_command.command == beep_com_ir_all){							
 726:	8f e0       	ldi	r24, 0x0F	; 15
 728:	b8 12       	cpse	r11, r24
 72a:	bf cf       	rjmp	.-130    	; 0x6aa <main+0x14a>
							conv_left = 8;
 72c:	90 92 06 20 	sts	0x2006, r9
							direct_send_adc_res = true;
 730:	c0 92 00 20 	sts	0x2000, r12
							adc_channel = 0;
 734:	10 92 21 20 	sts	0x2021, r1
							start_adc(adc_channel);
 738:	80 91 21 20 	lds	r24, 0x2021
 73c:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <start_adc>
 740:	b4 cf       	rjmp	.-152    	; 0x6aa <main+0x14a>
						}
					
						//next_command.data_missing = -1;
					}else if(next_command.device == BEEP_DEV_RGB_LED){
 742:	00 35       	cpi	r16, 0x50	; 80
 744:	09 f0       	breq	.+2      	; 0x748 <main+0x1e8>
 746:	b1 cf       	rjmp	.-158    	; 0x6aa <main+0x14a>
						if(next_command.command == BEEP_COM_LEDS_OFF){
 748:	ef e0       	ldi	r30, 0x0F	; 15
 74a:	be 12       	cpse	r11, r30
 74c:	05 c0       	rjmp	.+10     	; 0x758 <main+0x1f8>
		//reset counter
		TCE0.CNT = 0x00;
		//restart counter
		TCE0.CTRLA = TC_CLKSEL_DIV1_gc;
	}else{
		TCE0.CTRLA = 0; // disable pwm output
 74e:	f7 01       	movw	r30, r14
 750:	10 82       	st	Z, r1
		PORTE.OUTCLR = PIN0_bm | PIN1_bm | PIN2_bm; // clear outputs
 752:	f3 01       	movw	r30, r6
 754:	86 82       	std	Z+6, r8	; 0x06
 756:	a9 cf       	rjmp	.-174    	; 0x6aa <main+0x14a>
					
						//next_command.data_missing = -1;
					}else if(next_command.device == BEEP_DEV_RGB_LED){
						if(next_command.command == BEEP_COM_LEDS_OFF){
							enable_rgb_leds(false);
						}else if(next_command.command == BEEP_COM_LEDS_ON){
 758:	fe e0       	ldi	r31, 0x0E	; 14
 75a:	bf 12       	cpse	r11, r31
 75c:	05 c0       	rjmp	.+10     	; 0x768 <main+0x208>


inline void enable_rgb_leds(bool enable){
	if (enable){
		//reset counter
		TCE0.CNT = 0x00;
 75e:	f7 01       	movw	r30, r14
 760:	10 a2       	std	Z+32, r1	; 0x20
 762:	11 a2       	std	Z+33, r1	; 0x21
		//restart counter
		TCE0.CTRLA = TC_CLKSEL_DIV1_gc;
 764:	c0 82       	st	Z, r12
 766:	a1 cf       	rjmp	.-190    	; 0x6aa <main+0x14a>
					}else if(next_command.device == BEEP_DEV_RGB_LED){
						if(next_command.command == BEEP_COM_LEDS_OFF){
							enable_rgb_leds(false);
						}else if(next_command.command == BEEP_COM_LEDS_ON){
							enable_rgb_leds(true);
						}else if(next_command.command < 8){
 768:	f7 e0       	ldi	r31, 0x07	; 7
 76a:	fb 15       	cp	r31, r11
 76c:	08 f0       	brcs	.+2      	; 0x770 <main+0x210>
 76e:	93 cf       	rjmp	.-218    	; 0x696 <main+0x136>
 770:	9c cf       	rjmp	.-200    	; 0x6aa <main+0x14a>
							next_command.data_missing = 3;
						}
					}
				}else{
					next_command.data[next_command.head] = data;
 772:	e4 e0       	ldi	r30, 0x04	; 4
 774:	f0 e0       	ldi	r31, 0x00	; 0
 776:	ec 0f       	add	r30, r28
 778:	fd 1f       	adc	r31, r29
 77a:	ea 0d       	add	r30, r10
 77c:	f1 1d       	adc	r31, r1
 77e:	80 83       	st	Z, r24
					next_command.head += 1;
					next_command.data_missing -= 1;
 780:	11 50       	subi	r17, 0x01	; 1
					if (next_command.data_missing == 0){					
 782:	11 f0       	breq	.+4      	; 0x788 <main+0x228>
							next_command.data_missing = 3;
						}
					}
				}else{
					next_command.data[next_command.head] = data;
					next_command.head += 1;
 784:	a3 94       	inc	r10
 786:	91 cf       	rjmp	.-222    	; 0x6aa <main+0x14a>
					next_command.data_missing -= 1;
					if (next_command.data_missing == 0){					
						if(next_command.device==beep_dev_motors){
 788:	00 34       	cpi	r16, 0x40	; 64
 78a:	11 f5       	brne	.+68     	; 0x7d0 <main+0x270>
							if(next_command.command == beep_com_left_motor){
 78c:	81 e0       	ldi	r24, 0x01	; 1
 78e:	b8 12       	cpse	r11, r24
 790:	07 c0       	rjmp	.+14     	; 0x7a0 <main+0x240>
								set_beepmotor_speed(motor_l, next_command.data[0]);
 792:	6c 81       	ldd	r22, Y+4	; 0x04
 794:	84 e0       	ldi	r24, 0x04	; 4
 796:	0e 94 87 02 	call	0x50e	; 0x50e <set_beepmotor_speed>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 79a:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 79c:	1d 2d       	mov	r17, r13
 79e:	85 cf       	rjmp	.-246    	; 0x6aa <main+0x14a>
					next_command.data_missing -= 1;
					if (next_command.data_missing == 0){					
						if(next_command.device==beep_dev_motors){
							if(next_command.command == beep_com_left_motor){
								set_beepmotor_speed(motor_l, next_command.data[0]);
							}else if(next_command.command == beep_com_right_motor){
 7a0:	e2 e0       	ldi	r30, 0x02	; 2
 7a2:	be 12       	cpse	r11, r30
 7a4:	07 c0       	rjmp	.+14     	; 0x7b4 <main+0x254>
								set_beepmotor_speed(motor_r, next_command.data[0]);
 7a6:	6c 81       	ldd	r22, Y+4	; 0x04
 7a8:	86 e0       	ldi	r24, 0x06	; 6
 7aa:	0e 94 87 02 	call	0x50e	; 0x50e <set_beepmotor_speed>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 7ae:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 7b0:	1d 2d       	mov	r17, r13
 7b2:	7b cf       	rjmp	.-266    	; 0x6aa <main+0x14a>
						if(next_command.device==beep_dev_motors){
							if(next_command.command == beep_com_left_motor){
								set_beepmotor_speed(motor_l, next_command.data[0]);
							}else if(next_command.command == beep_com_right_motor){
								set_beepmotor_speed(motor_r, next_command.data[0]);
							}else if(next_command.command == beep_com_both_motors){
 7b4:	f3 e0       	ldi	r31, 0x03	; 3
 7b6:	bf 12       	cpse	r11, r31
 7b8:	70 cf       	rjmp	.-288    	; 0x69a <main+0x13a>
								set_beepmotor_speed(motor_l, next_command.data[0]);
 7ba:	6c 81       	ldd	r22, Y+4	; 0x04
 7bc:	84 e0       	ldi	r24, 0x04	; 4
 7be:	0e 94 87 02 	call	0x50e	; 0x50e <set_beepmotor_speed>
								set_beepmotor_speed(motor_r, next_command.data[1]);
 7c2:	6d 81       	ldd	r22, Y+5	; 0x05
 7c4:	86 e0       	ldi	r24, 0x06	; 6
 7c6:	0e 94 87 02 	call	0x50e	; 0x50e <set_beepmotor_speed>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 7ca:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 7cc:	1d 2d       	mov	r17, r13
 7ce:	6d cf       	rjmp	.-294    	; 0x6aa <main+0x14a>
								set_beepmotor_speed(motor_r, next_command.data[0]);
							}else if(next_command.command == beep_com_both_motors){
								set_beepmotor_speed(motor_l, next_command.data[0]);
								set_beepmotor_speed(motor_r, next_command.data[1]);
							}
						}else if(next_command.device == BEEP_DEV_RGB_LED){
 7d0:	00 35       	cpi	r16, 0x50	; 80
 7d2:	09 f0       	breq	.+2      	; 0x7d6 <main+0x276>
 7d4:	65 cf       	rjmp	.-310    	; 0x6a0 <main+0x140>
							if (next_command.command < 8){
 7d6:	87 e0       	ldi	r24, 0x07	; 7
 7d8:	8b 15       	cp	r24, r11
 7da:	08 f4       	brcc	.+2      	; 0x7de <main+0x27e>
 7dc:	64 cf       	rjmp	.-312    	; 0x6a6 <main+0x146>
								myColors[next_command.command].red = next_command.data[0];
 7de:	2b 2d       	mov	r18, r11
 7e0:	30 e0       	ldi	r19, 0x00	; 0
 7e2:	8c 81       	ldd	r24, Y+4	; 0x04
 7e4:	f9 01       	movw	r30, r18
 7e6:	ee 0f       	add	r30, r30
 7e8:	ff 1f       	adc	r31, r31
 7ea:	2e 0f       	add	r18, r30
 7ec:	3f 1f       	adc	r19, r31
 7ee:	f9 01       	movw	r30, r18
 7f0:	e7 5f       	subi	r30, 0xF7	; 247
 7f2:	ff 4d       	sbci	r31, 0xDF	; 223
 7f4:	80 83       	st	Z, r24
								myColors[next_command.command].green = next_command.data[1];
 7f6:	8d 81       	ldd	r24, Y+5	; 0x05
 7f8:	81 83       	std	Z+1, r24	; 0x01
								myColors[next_command.command].blue = next_command.data[2];
 7fa:	8e 81       	ldd	r24, Y+6	; 0x06
 7fc:	82 83       	std	Z+2, r24	; 0x02
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 7fe:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 800:	1d 2d       	mov	r17, r13
 802:	53 cf       	rjmp	.-346    	; 0x6aa <main+0x14a>

00000804 <__vector_88>:
		}
    }
}


ISR(USARTD0_RXC_vect){
 804:	1f 92       	push	r1
 806:	0f 92       	push	r0
 808:	0f b6       	in	r0, 0x3f	; 63
 80a:	0f 92       	push	r0
 80c:	11 24       	eor	r1, r1
 80e:	0b b6       	in	r0, 0x3b	; 59
 810:	0f 92       	push	r0
 812:	2f 93       	push	r18
 814:	3f 93       	push	r19
 816:	4f 93       	push	r20
 818:	5f 93       	push	r21
 81a:	6f 93       	push	r22
 81c:	7f 93       	push	r23
 81e:	8f 93       	push	r24
 820:	9f 93       	push	r25
 822:	af 93       	push	r26
 824:	bf 93       	push	r27
 826:	ef 93       	push	r30
 828:	ff 93       	push	r31
	USART_RXComplete(&USART_data);
 82a:	8a e2       	ldi	r24, 0x2A	; 42
 82c:	90 e2       	ldi	r25, 0x20	; 32
 82e:	0e 94 ab 05 	call	0xb56	; 0xb56 <USART_RXComplete>
}
 832:	ff 91       	pop	r31
 834:	ef 91       	pop	r30
 836:	bf 91       	pop	r27
 838:	af 91       	pop	r26
 83a:	9f 91       	pop	r25
 83c:	8f 91       	pop	r24
 83e:	7f 91       	pop	r23
 840:	6f 91       	pop	r22
 842:	5f 91       	pop	r21
 844:	4f 91       	pop	r20
 846:	3f 91       	pop	r19
 848:	2f 91       	pop	r18
 84a:	0f 90       	pop	r0
 84c:	0b be       	out	0x3b, r0	; 59
 84e:	0f 90       	pop	r0
 850:	0f be       	out	0x3f, r0	; 63
 852:	0f 90       	pop	r0
 854:	1f 90       	pop	r1
 856:	18 95       	reti

00000858 <__vector_89>:


ISR(USARTD0_DRE_vect){
 858:	1f 92       	push	r1
 85a:	0f 92       	push	r0
 85c:	0f b6       	in	r0, 0x3f	; 63
 85e:	0f 92       	push	r0
 860:	11 24       	eor	r1, r1
 862:	0b b6       	in	r0, 0x3b	; 59
 864:	0f 92       	push	r0
 866:	2f 93       	push	r18
 868:	3f 93       	push	r19
 86a:	4f 93       	push	r20
 86c:	5f 93       	push	r21
 86e:	6f 93       	push	r22
 870:	7f 93       	push	r23
 872:	8f 93       	push	r24
 874:	9f 93       	push	r25
 876:	af 93       	push	r26
 878:	bf 93       	push	r27
 87a:	ef 93       	push	r30
 87c:	ff 93       	push	r31
	USART_DataRegEmpty(&USART_data);
 87e:	8a e2       	ldi	r24, 0x2A	; 42
 880:	90 e2       	ldi	r25, 0x20	; 32
 882:	0e 94 c0 05 	call	0xb80	; 0xb80 <USART_DataRegEmpty>
}
 886:	ff 91       	pop	r31
 888:	ef 91       	pop	r30
 88a:	bf 91       	pop	r27
 88c:	af 91       	pop	r26
 88e:	9f 91       	pop	r25
 890:	8f 91       	pop	r24
 892:	7f 91       	pop	r23
 894:	6f 91       	pop	r22
 896:	5f 91       	pop	r21
 898:	4f 91       	pop	r20
 89a:	3f 91       	pop	r19
 89c:	2f 91       	pop	r18
 89e:	0f 90       	pop	r0
 8a0:	0b be       	out	0x3b, r0	; 59
 8a2:	0f 90       	pop	r0
 8a4:	0f be       	out	0x3f, r0	; 63
 8a6:	0f 90       	pop	r0
 8a8:	1f 90       	pop	r1
 8aa:	18 95       	reti

000008ac <__vector_71>:

ISR(ADCA_CH0_vect){
 8ac:	1f 92       	push	r1
 8ae:	0f 92       	push	r0
 8b0:	0f b6       	in	r0, 0x3f	; 63
 8b2:	0f 92       	push	r0
 8b4:	11 24       	eor	r1, r1
 8b6:	0b b6       	in	r0, 0x3b	; 59
 8b8:	0f 92       	push	r0
 8ba:	2f 93       	push	r18
 8bc:	3f 93       	push	r19
 8be:	4f 93       	push	r20
 8c0:	5f 93       	push	r21
 8c2:	6f 93       	push	r22
 8c4:	7f 93       	push	r23
 8c6:	8f 93       	push	r24
 8c8:	9f 93       	push	r25
 8ca:	af 93       	push	r26
 8cc:	bf 93       	push	r27
 8ce:	ef 93       	push	r30
 8d0:	ff 93       	push	r31
	if(direct_send_adc_res){
 8d2:	80 91 00 20 	lds	r24, 0x2000
 8d6:	88 23       	and	r24, r24
 8d8:	01 f1       	breq	.+64     	; 0x91a <__vector_71+0x6e>
		USART_TXBuffer_PutByte(&USART_data, ADCA.CH0.RES / (2047 / 255));
 8da:	e0 e0       	ldi	r30, 0x00	; 0
 8dc:	f2 e0       	ldi	r31, 0x02	; 2
 8de:	64 a1       	ldd	r22, Z+36	; 0x24
 8e0:	75 a1       	ldd	r23, Z+37	; 0x25
 8e2:	76 95       	lsr	r23
 8e4:	67 95       	ror	r22
 8e6:	76 95       	lsr	r23
 8e8:	67 95       	ror	r22
 8ea:	76 95       	lsr	r23
 8ec:	67 95       	ror	r22
 8ee:	8a e2       	ldi	r24, 0x2A	; 42
 8f0:	90 e2       	ldi	r25, 0x20	; 32
 8f2:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <USART_TXBuffer_PutByte>
		adc_channel += 1;
 8f6:	80 91 21 20 	lds	r24, 0x2021
 8fa:	8f 5f       	subi	r24, 0xFF	; 255
 8fc:	80 93 21 20 	sts	0x2021, r24
		conv_left -= 1;
 900:	80 91 06 20 	lds	r24, 0x2006
 904:	81 50       	subi	r24, 0x01	; 1
 906:	80 93 06 20 	sts	0x2006, r24
		if (conv_left>0){
 90a:	80 91 06 20 	lds	r24, 0x2006
 90e:	88 23       	and	r24, r24
 910:	21 f0       	breq	.+8      	; 0x91a <__vector_71+0x6e>
			start_adc(adc_channel);
 912:	80 91 21 20 	lds	r24, 0x2021
 916:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <start_adc>
		}
	}
}
 91a:	ff 91       	pop	r31
 91c:	ef 91       	pop	r30
 91e:	bf 91       	pop	r27
 920:	af 91       	pop	r26
 922:	9f 91       	pop	r25
 924:	8f 91       	pop	r24
 926:	7f 91       	pop	r23
 928:	6f 91       	pop	r22
 92a:	5f 91       	pop	r21
 92c:	4f 91       	pop	r20
 92e:	3f 91       	pop	r19
 930:	2f 91       	pop	r18
 932:	0f 90       	pop	r0
 934:	0b be       	out	0x3b, r0	; 59
 936:	0f 90       	pop	r0
 938:	0f be       	out	0x3f, r0	; 63
 93a:	0f 90       	pop	r0
 93c:	1f 90       	pop	r1
 93e:	18 95       	reti

00000940 <__vector_47>:

ISR(TCE0_OVF_vect){
 940:	1f 92       	push	r1
 942:	0f 92       	push	r0
 944:	0f b6       	in	r0, 0x3f	; 63
 946:	0f 92       	push	r0
 948:	11 24       	eor	r1, r1
 94a:	0b b6       	in	r0, 0x3b	; 59
 94c:	0f 92       	push	r0
 94e:	2f 93       	push	r18
 950:	3f 93       	push	r19
 952:	4f 93       	push	r20
 954:	8f 93       	push	r24
 956:	9f 93       	push	r25
 958:	af 93       	push	r26
 95a:	bf 93       	push	r27
 95c:	cf 93       	push	r28
 95e:	df 93       	push	r29
 960:	ef 93       	push	r30
 962:	ff 93       	push	r31
	static uint8_t led_multiplex_counter = 0; //software prescale
	static uint8_t led = 0; //next led number
	if(led_multiplex_counter++ > 0x5){
 964:	80 91 07 20 	lds	r24, 0x2007
 968:	86 30       	cpi	r24, 0x06	; 6
 96a:	20 f4       	brcc	.+8      	; 0x974 <__vector_47+0x34>
 96c:	8f 5f       	subi	r24, 0xFF	; 255
 96e:	80 93 07 20 	sts	0x2007, r24
 972:	52 c0       	rjmp	.+164    	; 0xa18 <__vector_47+0xd8>
		led_multiplex_counter=0;
 974:	10 92 07 20 	sts	0x2007, r1
		//reset counter
		TCE0.CNT = 0x00;
		//restart counter
		TCE0.CTRLA = TC_CLKSEL_DIV1_gc;
	}else{
		TCE0.CTRLA = 0; // disable pwm output
 978:	a0 e0       	ldi	r26, 0x00	; 0
 97a:	ba e0       	ldi	r27, 0x0A	; 10
 97c:	1c 92       	st	X, r1
		PORTE.OUTCLR = PIN0_bm | PIN1_bm | PIN2_bm; // clear outputs
 97e:	87 e0       	ldi	r24, 0x07	; 7
 980:	e0 e8       	ldi	r30, 0x80	; 128
 982:	f6 e0       	ldi	r31, 0x06	; 6
 984:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 986:	8f e3       	ldi	r24, 0x3F	; 63
 988:	9f e1       	ldi	r25, 0x1F	; 31
 98a:	01 97       	sbiw	r24, 0x01	; 1
 98c:	f1 f7       	brne	.-4      	; 0x98a <__vector_47+0x4a>
 98e:	00 c0       	rjmp	.+0      	; 0x990 <__vector_47+0x50>
 990:	00 00       	nop
		enable_rgb_leds(false);

		_delay_ms(1);
		
		//set pwm values
		PWM_RED = pgm_read_word (&pwmtable_12[myColors[led].red]);
 992:	40 91 08 20 	lds	r20, 0x2008
 996:	84 2f       	mov	r24, r20
 998:	90 e0       	ldi	r25, 0x00	; 0
 99a:	ec 01       	movw	r28, r24
 99c:	cc 0f       	add	r28, r28
 99e:	dd 1f       	adc	r29, r29
 9a0:	c8 0f       	add	r28, r24
 9a2:	d9 1f       	adc	r29, r25
 9a4:	c7 5f       	subi	r28, 0xF7	; 247
 9a6:	df 4d       	sbci	r29, 0xDF	; 223
 9a8:	e8 81       	ld	r30, Y
 9aa:	f0 e0       	ldi	r31, 0x00	; 0
 9ac:	ee 0f       	add	r30, r30
 9ae:	ff 1f       	adc	r31, r31
 9b0:	e8 52       	subi	r30, 0x28	; 40
 9b2:	fe 4f       	sbci	r31, 0xFE	; 254
 9b4:	25 91       	lpm	r18, Z+
 9b6:	34 91       	lpm	r19, Z
 9b8:	9c 96       	adiw	r26, 0x2c	; 44
 9ba:	2d 93       	st	X+, r18
 9bc:	3c 93       	st	X, r19
 9be:	9d 97       	sbiw	r26, 0x2d	; 45
		PWM_GREEN = pgm_read_word(&pwmtable_12[myColors[led].green]);
 9c0:	e9 81       	ldd	r30, Y+1	; 0x01
 9c2:	f0 e0       	ldi	r31, 0x00	; 0
 9c4:	ee 0f       	add	r30, r30
 9c6:	ff 1f       	adc	r31, r31
 9c8:	e8 52       	subi	r30, 0x28	; 40
 9ca:	fe 4f       	sbci	r31, 0xFE	; 254
 9cc:	25 91       	lpm	r18, Z+
 9ce:	34 91       	lpm	r19, Z
 9d0:	98 96       	adiw	r26, 0x28	; 40
 9d2:	2d 93       	st	X+, r18
 9d4:	3c 93       	st	X, r19
 9d6:	99 97       	sbiw	r26, 0x29	; 41
		PWM_BLUE = pgm_read_word (&pwmtable_12[myColors[led].blue]);
 9d8:	ea 81       	ldd	r30, Y+2	; 0x02
 9da:	f0 e0       	ldi	r31, 0x00	; 0
 9dc:	ee 0f       	add	r30, r30
 9de:	ff 1f       	adc	r31, r31
 9e0:	e8 52       	subi	r30, 0x28	; 40
 9e2:	fe 4f       	sbci	r31, 0xFE	; 254
 9e4:	25 91       	lpm	r18, Z+
 9e6:	34 91       	lpm	r19, Z
 9e8:	9a 96       	adiw	r26, 0x2a	; 42
 9ea:	2d 93       	st	X+, r18
 9ec:	3c 93       	st	X, r19
 9ee:	9b 97       	sbiw	r26, 0x2b	; 43

		//choose LED on multiplexer
		PORTF.OUTCLR = (0b111 << 3);
 9f0:	c0 ea       	ldi	r28, 0xA0	; 160
 9f2:	d6 e0       	ldi	r29, 0x06	; 6
 9f4:	28 e3       	ldi	r18, 0x38	; 56
 9f6:	2e 83       	std	Y+6, r18	; 0x06
		PORTF.OUTSET = (pgm_read_word (&rgb_led_lut[led]));
 9f8:	80 53       	subi	r24, 0x30	; 48
 9fa:	9e 4f       	sbci	r25, 0xFE	; 254
 9fc:	fc 01       	movw	r30, r24
 9fe:	85 91       	lpm	r24, Z+
 a00:	94 91       	lpm	r25, Z
 a02:	8d 83       	std	Y+5, r24	; 0x05


inline void enable_rgb_leds(bool enable){
	if (enable){
		//reset counter
		TCE0.CNT = 0x00;
 a04:	90 96       	adiw	r26, 0x20	; 32
 a06:	1d 92       	st	X+, r1
 a08:	1c 92       	st	X, r1
 a0a:	91 97       	sbiw	r26, 0x21	; 33
		//restart counter
		TCE0.CTRLA = TC_CLKSEL_DIV1_gc;
 a0c:	81 e0       	ldi	r24, 0x01	; 1
 a0e:	8c 93       	st	X, r24
		PORTF.OUTSET = (pgm_read_word (&rgb_led_lut[led]));

		enable_rgb_leds(true);

		//select next LED
		led++;
 a10:	4f 5f       	subi	r20, 0xFF	; 255
		led &= 0b111;
 a12:	47 70       	andi	r20, 0x07	; 7
 a14:	40 93 08 20 	sts	0x2008, r20
	}
 a18:	ff 91       	pop	r31
 a1a:	ef 91       	pop	r30
 a1c:	df 91       	pop	r29
 a1e:	cf 91       	pop	r28
 a20:	bf 91       	pop	r27
 a22:	af 91       	pop	r26
 a24:	9f 91       	pop	r25
 a26:	8f 91       	pop	r24
 a28:	4f 91       	pop	r20
 a2a:	3f 91       	pop	r19
 a2c:	2f 91       	pop	r18
 a2e:	0f 90       	pop	r0
 a30:	0b be       	out	0x3b, r0	; 59
 a32:	0f 90       	pop	r0
 a34:	0f be       	out	0x3f, r0	; 63
 a36:	0f 90       	pop	r0
 a38:	1f 90       	pop	r1
 a3a:	18 95       	reti

00000a3c <set_motor_operation_mode>:
#include "motor_driver.h"

void set_motor_operation_mode(motor_t motor, motor_op_mode_t op){
	PORTE.OUTCLR = 0b11 << motor;
 a3c:	23 e0       	ldi	r18, 0x03	; 3
 a3e:	30 e0       	ldi	r19, 0x00	; 0
 a40:	08 2e       	mov	r0, r24
 a42:	02 c0       	rjmp	.+4      	; 0xa48 <set_motor_operation_mode+0xc>
 a44:	22 0f       	add	r18, r18
 a46:	33 1f       	adc	r19, r19
 a48:	0a 94       	dec	r0
 a4a:	e2 f7       	brpl	.-8      	; 0xa44 <set_motor_operation_mode+0x8>
 a4c:	e0 e8       	ldi	r30, 0x80	; 128
 a4e:	f6 e0       	ldi	r31, 0x06	; 6
 a50:	26 83       	std	Z+6, r18	; 0x06
	PORTE.OUTSET = op << motor;
 a52:	70 e0       	ldi	r23, 0x00	; 0
 a54:	9b 01       	movw	r18, r22
 a56:	02 c0       	rjmp	.+4      	; 0xa5c <set_motor_operation_mode+0x20>
 a58:	22 0f       	add	r18, r18
 a5a:	33 1f       	adc	r19, r19
 a5c:	8a 95       	dec	r24
 a5e:	e2 f7       	brpl	.-8      	; 0xa58 <set_motor_operation_mode+0x1c>
 a60:	25 83       	std	Z+5, r18	; 0x05
 a62:	08 95       	ret

00000a64 <init_motor>:
}

void init_motor(void){
 	PORTE.DIRSET = PIN4_bm | PIN5_bm | PIN6_bm | PIN7_bm; //Set Motor control as output
 a64:	80 ef       	ldi	r24, 0xF0	; 240
 a66:	e0 e8       	ldi	r30, 0x80	; 128
 a68:	f6 e0       	ldi	r31, 0x06	; 6
 a6a:	81 83       	std	Z+1, r24	; 0x01
 	PORTA.DIRSET = PIN6_bm; // Standby as output
 a6c:	80 e4       	ldi	r24, 0x40	; 64
 a6e:	e0 e0       	ldi	r30, 0x00	; 0
 a70:	f6 e0       	ldi	r31, 0x06	; 6
 a72:	81 83       	std	Z+1, r24	; 0x01
 	PORTC.DIRSET = PIN2_bm | PIN3_bm; //PWM as output
 a74:	8c e0       	ldi	r24, 0x0C	; 12
 a76:	e0 e4       	ldi	r30, 0x40	; 64
 a78:	f6 e0       	ldi	r31, 0x06	; 6
 a7a:	81 83       	std	Z+1, r24	; 0x01
 	
 	TCC0.CTRLA = TC_CLKSEL_DIV1_gc; //prescaler: Clk/1
 a7c:	e0 e0       	ldi	r30, 0x00	; 0
 a7e:	f8 e0       	ldi	r31, 0x08	; 8
 a80:	81 e0       	ldi	r24, 0x01	; 1
 a82:	80 83       	st	Z, r24
 	TCC0.CTRLB = TC0_CCCEN_bm|TC0_CCDEN_bm| TC_WGMODE_SS_gc; //enable pwm output, Single slope pwm
 a84:	83 ec       	ldi	r24, 0xC3	; 195
 a86:	81 83       	std	Z+1, r24	; 0x01
 	
 	TCC0.PER = 0xff;
 a88:	8f ef       	ldi	r24, 0xFF	; 255
 a8a:	90 e0       	ldi	r25, 0x00	; 0
 a8c:	86 a3       	std	Z+38, r24	; 0x26
 a8e:	97 a3       	std	Z+39, r25	; 0x27
 a90:	08 95       	ret

00000a92 <set_motor_speed>:
	

}

void set_motor_speed(motor_t motor, uint8_t speed){
 a92:	6b 3a       	cpi	r22, 0xAB	; 171
 a94:	08 f0       	brcs	.+2      	; 0xa98 <set_motor_speed+0x6>
 a96:	6a ea       	ldi	r22, 0xAA	; 170
	if(speed > 0xaa){//ensure 5V average
		speed = 0xaa;
	}
	
	if(motor == motor_l){
 a98:	84 30       	cpi	r24, 0x04	; 4
 a9a:	31 f4       	brne	.+12     	; 0xaa8 <set_motor_speed+0x16>
		TCC0.CCD = speed;
 a9c:	70 e0       	ldi	r23, 0x00	; 0
 a9e:	e0 e0       	ldi	r30, 0x00	; 0
 aa0:	f8 e0       	ldi	r31, 0x08	; 8
 aa2:	66 a7       	std	Z+46, r22	; 0x2e
 aa4:	77 a7       	std	Z+47, r23	; 0x2f
 aa6:	08 95       	ret
	} else if(motor == motor_r){
 aa8:	86 30       	cpi	r24, 0x06	; 6
 aaa:	29 f4       	brne	.+10     	; 0xab6 <set_motor_speed+0x24>
		TCC0.CCC = speed;
 aac:	70 e0       	ldi	r23, 0x00	; 0
 aae:	e0 e0       	ldi	r30, 0x00	; 0
 ab0:	f8 e0       	ldi	r31, 0x08	; 8
 ab2:	64 a7       	std	Z+44, r22	; 0x2c
 ab4:	75 a7       	std	Z+45, r23	; 0x2d
 ab6:	08 95       	ret

00000ab8 <set_motor_on>:
	}
}

void set_motor_on(bool b){
	if(b){
 ab8:	88 23       	and	r24, r24
 aba:	29 f0       	breq	.+10     	; 0xac6 <set_motor_on+0xe>
		PORTA.OUTSET = PIN6_bm;
 abc:	80 e4       	ldi	r24, 0x40	; 64
 abe:	e0 e0       	ldi	r30, 0x00	; 0
 ac0:	f6 e0       	ldi	r31, 0x06	; 6
 ac2:	85 83       	std	Z+5, r24	; 0x05
 ac4:	08 95       	ret
		}else{
		PORTA.OUTCLR = PIN6_bm;
 ac6:	80 e4       	ldi	r24, 0x40	; 64
 ac8:	e0 e0       	ldi	r30, 0x00	; 0
 aca:	f6 e0       	ldi	r31, 0x06	; 6
 acc:	86 83       	std	Z+6, r24	; 0x06
 ace:	08 95       	ret

00000ad0 <USART_InterruptDriver_Initialize>:
 *  \param dreIntLevel          Data register empty interrupt level.
 */
void USART_InterruptDriver_Initialize(USART_data_t * usart_data,
                                      USART_t * usart,
                                      USART_DREINTLVL_t dreIntLevel)
{
 ad0:	fc 01       	movw	r30, r24
	usart_data->usart = usart;
 ad2:	60 83       	st	Z, r22
 ad4:	71 83       	std	Z+1, r23	; 0x01
	usart_data->dreIntLevel = dreIntLevel;
 ad6:	42 83       	std	Z+2, r20	; 0x02

	usart_data->buffer.RX_Tail = 0;
 ad8:	14 86       	std	Z+12, r1	; 0x0c
	usart_data->buffer.RX_Head = 0;
 ada:	13 86       	std	Z+11, r1	; 0x0b
	usart_data->buffer.TX_Tail = 0;
 adc:	16 86       	std	Z+14, r1	; 0x0e
	usart_data->buffer.TX_Head = 0;
 ade:	15 86       	std	Z+13, r1	; 0x0d
 ae0:	08 95       	ret

00000ae2 <USART_TXBuffer_FreeSpace>:
 *  \retval false     The receive buffer is empty.
 */
bool USART_TXBuffer_FreeSpace(USART_data_t * usart_data)
{
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = (usart_data->buffer.TX_Head + 1) & USART_TX_BUFFER_MASK;
 ae2:	fc 01       	movw	r30, r24
 ae4:	25 85       	ldd	r18, Z+13	; 0x0d
	uint8_t tempTail = usart_data->buffer.TX_Tail;
 ae6:	96 85       	ldd	r25, Z+14	; 0x0e
 *  \retval false     The receive buffer is empty.
 */
bool USART_TXBuffer_FreeSpace(USART_data_t * usart_data)
{
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = (usart_data->buffer.TX_Head + 1) & USART_TX_BUFFER_MASK;
 ae8:	2f 5f       	subi	r18, 0xFF	; 255
 aea:	23 70       	andi	r18, 0x03	; 3
	uint8_t tempTail = usart_data->buffer.TX_Tail;

	/* There are data left in the buffer unless Head and Tail are equal. */
	return (tempHead != tempTail);
 aec:	81 e0       	ldi	r24, 0x01	; 1
 aee:	29 13       	cpse	r18, r25
 af0:	01 c0       	rjmp	.+2      	; 0xaf4 <USART_TXBuffer_FreeSpace+0x12>
 af2:	80 e0       	ldi	r24, 0x00	; 0
}
 af4:	08 95       	ret

00000af6 <USART_TXBuffer_PutByte>:
 *
 *  \param usart_data The USART_data_t struct instance.
 *  \param data       The data to send.
 */
bool USART_TXBuffer_PutByte(USART_data_t * usart_data, uint8_t data)
{
 af6:	1f 93       	push	r17
 af8:	cf 93       	push	r28
 afa:	df 93       	push	r29
 afc:	ec 01       	movw	r28, r24
 afe:	16 2f       	mov	r17, r22
	uint8_t tempTX_Head;
	bool TXBuffer_FreeSpace;
	USART_Buffer_t * TXbufPtr;

	TXbufPtr = &usart_data->buffer;
	TXBuffer_FreeSpace = USART_TXBuffer_FreeSpace(usart_data);
 b00:	0e 94 71 05 	call	0xae2	; 0xae2 <USART_TXBuffer_FreeSpace>


	if(TXBuffer_FreeSpace)
 b04:	88 23       	and	r24, r24
 b06:	79 f0       	breq	.+30     	; 0xb26 <USART_TXBuffer_PutByte+0x30>
	{
	  	tempTX_Head = TXbufPtr->TX_Head;
 b08:	9d 85       	ldd	r25, Y+13	; 0x0d
	  	TXbufPtr->TX[tempTX_Head]= data;
 b0a:	fe 01       	movw	r30, r28
 b0c:	e9 0f       	add	r30, r25
 b0e:	f1 1d       	adc	r31, r1
 b10:	17 83       	std	Z+7, r17	; 0x07
		/* Advance buffer head. */
		TXbufPtr->TX_Head = (tempTX_Head + 1) & USART_TX_BUFFER_MASK;
 b12:	9f 5f       	subi	r25, 0xFF	; 255
 b14:	93 70       	andi	r25, 0x03	; 3
 b16:	9d 87       	std	Y+13, r25	; 0x0d

		/* Enable DRE interrupt. */
		tempCTRLA = usart_data->usart->CTRLA;
 b18:	e8 81       	ld	r30, Y
 b1a:	f9 81       	ldd	r31, Y+1	; 0x01
 b1c:	93 81       	ldd	r25, Z+3	; 0x03
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | usart_data->dreIntLevel;
 b1e:	9c 7f       	andi	r25, 0xFC	; 252
 b20:	2a 81       	ldd	r18, Y+2	; 0x02
 b22:	92 2b       	or	r25, r18
		usart_data->usart->CTRLA = tempCTRLA;
 b24:	93 83       	std	Z+3, r25	; 0x03
	}
	return TXBuffer_FreeSpace;
}
 b26:	df 91       	pop	r29
 b28:	cf 91       	pop	r28
 b2a:	1f 91       	pop	r17
 b2c:	08 95       	ret

00000b2e <USART_RXBufferData_Available>:
 *  \retval false     The receive buffer is empty.
 */
bool USART_RXBufferData_Available(USART_data_t * usart_data)
{
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = usart_data->buffer.RX_Head;
 b2e:	fc 01       	movw	r30, r24
 b30:	23 85       	ldd	r18, Z+11	; 0x0b
	uint8_t tempTail = usart_data->buffer.RX_Tail;
 b32:	94 85       	ldd	r25, Z+12	; 0x0c

	/* There are data left in the buffer unless Head and Tail are equal. */
	return (tempHead != tempTail);
 b34:	81 e0       	ldi	r24, 0x01	; 1
 b36:	29 13       	cpse	r18, r25
 b38:	01 c0       	rjmp	.+2      	; 0xb3c <USART_RXBufferData_Available+0xe>
 b3a:	80 e0       	ldi	r24, 0x00	; 0
}
 b3c:	08 95       	ret

00000b3e <USART_RXBuffer_GetByte>:
 *  \param usart_data       The USART_data_t struct instance.
 *
 *  \return         Received data.
 */
uint8_t USART_RXBuffer_GetByte(USART_data_t * usart_data)
{
 b3e:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	uint8_t ans;

	bufPtr = &usart_data->buffer;
	ans = (bufPtr->RX[bufPtr->RX_Tail]);
 b40:	84 85       	ldd	r24, Z+12	; 0x0c
 b42:	df 01       	movw	r26, r30
 b44:	a8 0f       	add	r26, r24
 b46:	b1 1d       	adc	r27, r1
 b48:	13 96       	adiw	r26, 0x03	; 3
 b4a:	8c 91       	ld	r24, X

	/* Advance buffer tail. */
	bufPtr->RX_Tail = (bufPtr->RX_Tail + 1) & USART_RX_BUFFER_MASK;
 b4c:	94 85       	ldd	r25, Z+12	; 0x0c
 b4e:	9f 5f       	subi	r25, 0xFF	; 255
 b50:	93 70       	andi	r25, 0x03	; 3
 b52:	94 87       	std	Z+12, r25	; 0x0c

	return ans;
}
 b54:	08 95       	ret

00000b56 <USART_RXComplete>:
 *  Stores received data in RX software buffer.
 *
 *  \param usart_data      The USART_data_t struct instance.
 */
bool USART_RXComplete(USART_data_t * usart_data)
{
 b56:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	bool ans;

	bufPtr = &usart_data->buffer;
	/* Advance buffer head. */
	uint8_t tempRX_Head = (bufPtr->RX_Head + 1) & USART_RX_BUFFER_MASK;
 b58:	83 85       	ldd	r24, Z+11	; 0x0b
 b5a:	8f 5f       	subi	r24, 0xFF	; 255
 b5c:	83 70       	andi	r24, 0x03	; 3

	/* Check for overflow. */
	uint8_t tempRX_Tail = bufPtr->RX_Tail;
 b5e:	94 85       	ldd	r25, Z+12	; 0x0c
	uint8_t data = usart_data->usart->DATA;
 b60:	a0 81       	ld	r26, Z
 b62:	b1 81       	ldd	r27, Z+1	; 0x01
 b64:	2c 91       	ld	r18, X

	if (tempRX_Head == tempRX_Tail) {
 b66:	89 17       	cp	r24, r25
 b68:	49 f0       	breq	.+18     	; 0xb7c <USART_RXComplete+0x26>
	  	ans = false;
	}else{
		ans = true;
		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
 b6a:	93 85       	ldd	r25, Z+11	; 0x0b
 b6c:	df 01       	movw	r26, r30
 b6e:	a9 0f       	add	r26, r25
 b70:	b1 1d       	adc	r27, r1
 b72:	13 96       	adiw	r26, 0x03	; 3
 b74:	2c 93       	st	X, r18
		usart_data->buffer.RX_Head = tempRX_Head;
 b76:	83 87       	std	Z+11, r24	; 0x0b
	uint8_t data = usart_data->usart->DATA;

	if (tempRX_Head == tempRX_Tail) {
	  	ans = false;
	}else{
		ans = true;
 b78:	81 e0       	ldi	r24, 0x01	; 1
 b7a:	08 95       	ret
	/* Check for overflow. */
	uint8_t tempRX_Tail = bufPtr->RX_Tail;
	uint8_t data = usart_data->usart->DATA;

	if (tempRX_Head == tempRX_Tail) {
	  	ans = false;
 b7c:	80 e0       	ldi	r24, 0x00	; 0
		ans = true;
		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
		usart_data->buffer.RX_Head = tempRX_Head;
	}
	return ans;
}
 b7e:	08 95       	ret

00000b80 <USART_DataRegEmpty>:
 *  is empty. Argument is pointer to USART (USART_data_t).
 *
 *  \param usart_data      The USART_data_t struct instance.
 */
void USART_DataRegEmpty(USART_data_t * usart_data)
{
 b80:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	bufPtr = &usart_data->buffer;

	/* Check if all data is transmitted. */
	uint8_t tempTX_Tail = usart_data->buffer.TX_Tail;
 b82:	86 85       	ldd	r24, Z+14	; 0x0e
	if (bufPtr->TX_Head == tempTX_Tail){
 b84:	95 85       	ldd	r25, Z+13	; 0x0d
 b86:	98 13       	cpse	r25, r24
 b88:	07 c0       	rjmp	.+14     	; 0xb98 <USART_DataRegEmpty+0x18>
	    /* Disable DRE interrupts. */
		uint8_t tempCTRLA = usart_data->usart->CTRLA;
 b8a:	01 90       	ld	r0, Z+
 b8c:	f0 81       	ld	r31, Z
 b8e:	e0 2d       	mov	r30, r0
 b90:	83 81       	ldd	r24, Z+3	; 0x03
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
 b92:	8c 7f       	andi	r24, 0xFC	; 252
		usart_data->usart->CTRLA = tempCTRLA;
 b94:	83 83       	std	Z+3, r24	; 0x03
 b96:	08 95       	ret

	}else{
		/* Start transmitting. */
		uint8_t data = bufPtr->TX[usart_data->buffer.TX_Tail];
 b98:	86 85       	ldd	r24, Z+14	; 0x0e
 b9a:	df 01       	movw	r26, r30
 b9c:	a8 0f       	add	r26, r24
 b9e:	b1 1d       	adc	r27, r1
 ba0:	17 96       	adiw	r26, 0x07	; 7
 ba2:	8c 91       	ld	r24, X
		usart_data->usart->DATA = data;
 ba4:	a0 81       	ld	r26, Z
 ba6:	b1 81       	ldd	r27, Z+1	; 0x01
 ba8:	8c 93       	st	X, r24

		/* Advance buffer tail. */
		bufPtr->TX_Tail = (bufPtr->TX_Tail + 1) & USART_TX_BUFFER_MASK;
 baa:	86 85       	ldd	r24, Z+14	; 0x0e
 bac:	8f 5f       	subi	r24, 0xFF	; 255
 bae:	83 70       	andi	r24, 0x03	; 3
 bb0:	86 87       	std	Z+14, r24	; 0x0e
 bb2:	08 95       	ret

00000bb4 <__udivmodsi4>:
 bb4:	a1 e2       	ldi	r26, 0x21	; 33
 bb6:	1a 2e       	mov	r1, r26
 bb8:	aa 1b       	sub	r26, r26
 bba:	bb 1b       	sub	r27, r27
 bbc:	fd 01       	movw	r30, r26
 bbe:	0d c0       	rjmp	.+26     	; 0xbda <__udivmodsi4_ep>

00000bc0 <__udivmodsi4_loop>:
 bc0:	aa 1f       	adc	r26, r26
 bc2:	bb 1f       	adc	r27, r27
 bc4:	ee 1f       	adc	r30, r30
 bc6:	ff 1f       	adc	r31, r31
 bc8:	a2 17       	cp	r26, r18
 bca:	b3 07       	cpc	r27, r19
 bcc:	e4 07       	cpc	r30, r20
 bce:	f5 07       	cpc	r31, r21
 bd0:	20 f0       	brcs	.+8      	; 0xbda <__udivmodsi4_ep>
 bd2:	a2 1b       	sub	r26, r18
 bd4:	b3 0b       	sbc	r27, r19
 bd6:	e4 0b       	sbc	r30, r20
 bd8:	f5 0b       	sbc	r31, r21

00000bda <__udivmodsi4_ep>:
 bda:	66 1f       	adc	r22, r22
 bdc:	77 1f       	adc	r23, r23
 bde:	88 1f       	adc	r24, r24
 be0:	99 1f       	adc	r25, r25
 be2:	1a 94       	dec	r1
 be4:	69 f7       	brne	.-38     	; 0xbc0 <__udivmodsi4_loop>
 be6:	60 95       	com	r22
 be8:	70 95       	com	r23
 bea:	80 95       	com	r24
 bec:	90 95       	com	r25
 bee:	9b 01       	movw	r18, r22
 bf0:	ac 01       	movw	r20, r24
 bf2:	bd 01       	movw	r22, r26
 bf4:	cf 01       	movw	r24, r30
 bf6:	08 95       	ret

00000bf8 <_exit>:
 bf8:	f8 94       	cli

00000bfa <__stop_program>:
 bfa:	ff cf       	rjmp	.-2      	; 0xbfa <__stop_program>
