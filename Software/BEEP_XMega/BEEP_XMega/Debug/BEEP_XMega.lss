
BEEP_XMega.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000b98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00802000  00000b98  00000c2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000031  00802006  00802006  00000c32  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000c34  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  00001300  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00001397  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000108  00000000  00000000  000013c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002758  00000000  00000000  000014ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000006d3  00000000  00000000  00003c26  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000729  00000000  00000000  000042f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000310  00000000  00000000  00004a24  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001271  00000000  00000000  00004d34  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000e4b  00000000  00000000  00005fa5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000120  00000000  00000000  00006df0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 ec 01 	jmp	0x3d8	; 0x3d8 <__ctors_end>
   4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
   8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
   c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  10:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  14:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  18:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  1c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  20:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  24:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  28:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  2c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  30:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  34:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  38:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  3c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  40:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  44:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  48:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  4c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  50:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  54:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  58:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  5c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  60:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  64:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  68:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  6c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  70:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  74:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  78:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  7c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  80:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  84:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  88:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  8c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  90:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  94:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  98:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  9c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  a0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  a4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  a8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  ac:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  b0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  b4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  b8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  bc:	0c 94 7c 02 	jmp	0x4f8	; 0x4f8 <__vector_47>
  c0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  c4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  c8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  cc:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  d0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  d4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  d8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  dc:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  e0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  e4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  e8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  ec:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  f0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  f4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  f8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
  fc:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 100:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 104:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 108:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 10c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 110:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 114:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 118:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 11c:	0c 94 b4 04 	jmp	0x968	; 0x968 <__vector_71>
 120:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 124:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 128:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 12c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 130:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 134:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 138:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 13c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 140:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 144:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 148:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 14c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 150:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 154:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 158:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 15c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 160:	0c 94 60 04 	jmp	0x8c0	; 0x8c0 <__vector_88>
 164:	0c 94 8a 04 	jmp	0x914	; 0x914 <__vector_89>
 168:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 16c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 170:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 174:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 178:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 17c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 180:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 184:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 188:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 18c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 190:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 194:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 198:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 19c:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1a0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1a4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1a8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1ac:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1b0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1b4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1b8:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1bc:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1c0:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>
 1c4:	0c 94 0b 02 	jmp	0x416	; 0x416 <__bad_interrupt>

000001c8 <ir_led_lut>:
 1c8:	00 01 02 03 05 06 07 04                             ........

000001d0 <rgb_led_lut>:
 1d0:	00 20 10 30 08 28 18 38                             . .0.(.8

000001d8 <pwmtable_12>:
 1d8:	00 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00     ................
 1e8:	01 00 01 00 01 00 01 00 02 00 02 00 02 00 02 00     ................
 1f8:	02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00     ................
 208:	02 00 02 00 02 00 02 00 03 00 03 00 03 00 03 00     ................
 218:	03 00 03 00 03 00 03 00 03 00 03 00 04 00 04 00     ................
 228:	04 00 04 00 04 00 04 00 04 00 04 00 05 00 05 00     ................
 238:	05 00 05 00 05 00 05 00 06 00 06 00 06 00 06 00     ................
 248:	06 00 07 00 07 00 07 00 07 00 07 00 08 00 08 00     ................
 258:	08 00 09 00 09 00 09 00 09 00 0a 00 0a 00 0a 00     ................
 268:	0b 00 0b 00 0b 00 0c 00 0c 00 0d 00 0d 00 0d 00     ................
 278:	0e 00 0e 00 0f 00 0f 00 10 00 10 00 11 00 11 00     ................
 288:	12 00 13 00 13 00 14 00 15 00 15 00 16 00 17 00     ................
 298:	17 00 18 00 19 00 1a 00 1b 00 1b 00 1c 00 1d 00     ................
 2a8:	1e 00 1f 00 20 00 21 00 23 00 24 00 25 00 26 00     .... .!.#.$.%.&.
 2b8:	27 00 29 00 2a 00 2b 00 2d 00 2e 00 30 00 31 00     '.).*.+.-...0.1.
 2c8:	33 00 35 00 36 00 38 00 3a 00 3c 00 3e 00 40 00     3.5.6.8.:.<.>.@.
 2d8:	42 00 44 00 47 00 49 00 4b 00 4e 00 50 00 53 00     B.D.G.I.K.N.P.S.
 2e8:	56 00 59 00 5b 00 5f 00 62 00 65 00 68 00 6c 00     V.Y.[._.b.e.h.l.
 2f8:	6f 00 73 00 77 00 7b 00 7f 00 83 00 87 00 8c 00     o.s.w.{.........
 308:	90 00 95 00 9a 00 9f 00 a4 00 aa 00 af 00 b5 00     ................
 318:	bb 00 c1 00 c8 00 ce 00 d5 00 dc 00 e3 00 eb 00     ................
 328:	f2 00 fa 00 03 01 0b 01 14 01 1d 01 27 01 30 01     ............'.0.
 338:	3a 01 45 01 50 01 5b 01 66 01 72 01 7e 01 8b 01     :.E.P.[.f.r.~...
 348:	98 01 a5 01 b3 01 c2 01 d0 01 e0 01 f0 01 00 02     ................
 358:	11 02 22 02 34 02 47 02 5a 02 6e 02 83 02 98 02     ..".4.G.Z.n.....
 368:	ae 02 c4 02 dc 02 f4 02 0d 03 27 03 41 03 5d 03     ..........'.A.].
 378:	79 03 97 03 b5 03 d4 03 f5 03 16 04 39 04 5c 04     y...........9.\.
 388:	81 04 a7 04 cf 04 f7 04 21 05 4d 05 7a 05 a8 05     ........!.M.z...
 398:	d8 05 09 06 3c 06 71 06 a7 06 df 06 1a 07 56 07     ....<.q.......V.
 3a8:	94 07 d4 07 16 08 5a 08 a1 08 ea 08 35 09 83 09     ......Z.....5...
 3b8:	d3 09 26 0a 7c 0a d5 0a 30 0b 8f 0b f1 0b 56 0c     ..&.|...0.....V.
 3c8:	be 0c 2a 0d 99 0d 0c 0e 83 0e fd 0e 7c 0f ff 0f     ..*.........|...

000003d8 <__ctors_end>:
 3d8:	11 24       	eor	r1, r1
 3da:	1f be       	out	0x3f, r1	; 63
 3dc:	cf ef       	ldi	r28, 0xFF	; 255
 3de:	df e2       	ldi	r29, 0x2F	; 47
 3e0:	de bf       	out	0x3e, r29	; 62
 3e2:	cd bf       	out	0x3d, r28	; 61

000003e4 <__do_copy_data>:
 3e4:	10 e2       	ldi	r17, 0x20	; 32
 3e6:	a0 e0       	ldi	r26, 0x00	; 0
 3e8:	b0 e2       	ldi	r27, 0x20	; 32
 3ea:	e8 e9       	ldi	r30, 0x98	; 152
 3ec:	fb e0       	ldi	r31, 0x0B	; 11
 3ee:	00 e0       	ldi	r16, 0x00	; 0
 3f0:	0b bf       	out	0x3b, r16	; 59
 3f2:	02 c0       	rjmp	.+4      	; 0x3f8 <__do_copy_data+0x14>
 3f4:	07 90       	elpm	r0, Z+
 3f6:	0d 92       	st	X+, r0
 3f8:	a6 30       	cpi	r26, 0x06	; 6
 3fa:	b1 07       	cpc	r27, r17
 3fc:	d9 f7       	brne	.-10     	; 0x3f4 <__do_copy_data+0x10>

000003fe <__do_clear_bss>:
 3fe:	20 e2       	ldi	r18, 0x20	; 32
 400:	a6 e0       	ldi	r26, 0x06	; 6
 402:	b0 e2       	ldi	r27, 0x20	; 32
 404:	01 c0       	rjmp	.+2      	; 0x408 <.do_clear_bss_start>

00000406 <.do_clear_bss_loop>:
 406:	1d 92       	st	X+, r1

00000408 <.do_clear_bss_start>:
 408:	a7 33       	cpi	r26, 0x37	; 55
 40a:	b2 07       	cpc	r27, r18
 40c:	e1 f7       	brne	.-8      	; 0x406 <.do_clear_bss_loop>
 40e:	0e 94 28 03 	call	0x650	; 0x650 <main>
 412:	0c 94 ca 05 	jmp	0xb94	; 0xb94 <_exit>

00000416 <__bad_interrupt>:
 416:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000041a <init_enable_32mhz>:




void init_enable_32mhz(void){
		OSC.CTRL |= OSC_RC32MEN_bm; //Enable 32 Mhz oscillator
 41a:	e0 e5       	ldi	r30, 0x50	; 80
 41c:	f0 e0       	ldi	r31, 0x00	; 0
 41e:	80 81       	ld	r24, Z
 420:	82 60       	ori	r24, 0x02	; 2
 422:	80 83       	st	Z, r24
		while(!(OSC.STATUS & OSC_RC32MRDY_bm)); //Wait until 32 Mhz oscillator is ready
 424:	81 81       	ldd	r24, Z+1	; 0x01
 426:	81 ff       	sbrs	r24, 1
 428:	fd cf       	rjmp	.-6      	; 0x424 <init_enable_32mhz+0xa>
		CCP = CCP_IOREG_gc; //Disable configuration change protection for four cycles
 42a:	88 ed       	ldi	r24, 0xD8	; 216
 42c:	84 bf       	out	0x34, r24	; 52
		CLK.CTRL = CLK_SCLKSEL_RC32M_gc; //Set 32Mhz as main clock
 42e:	81 e0       	ldi	r24, 0x01	; 1
 430:	80 93 40 00 	sts	0x0040, r24
		OSC.CTRL &= ~OSC_RC2MEN_bm; //Disable 2 Mhz oscillator
 434:	e0 e5       	ldi	r30, 0x50	; 80
 436:	f0 e0       	ldi	r31, 0x00	; 0
 438:	80 81       	ld	r24, Z
 43a:	8e 7f       	andi	r24, 0xFE	; 254
 43c:	80 83       	st	Z, r24
 43e:	08 95       	ret

00000440 <init_usart>:
}

void init_usart(void){
 440:	cf 93       	push	r28
 442:	df 93       	push	r29
	// Output TX
	PORTD.DIRSET = PIN3_bm;
 444:	e0 e6       	ldi	r30, 0x60	; 96
 446:	f6 e0       	ldi	r31, 0x06	; 6
 448:	88 e0       	ldi	r24, 0x08	; 8
 44a:	81 83       	std	Z+1, r24	; 0x01
	// Input RX
	PORTD.DIRCLR = PIN2_bm;
 44c:	84 e0       	ldi	r24, 0x04	; 4
 44e:	82 83       	std	Z+2, r24	; 0x02
	
	// init Buffers using USARTD0
	USART_InterruptDriver_Initialize(&USART_data, &USARTD0, USART_DREINTLVL_LO_gc);
 450:	41 e0       	ldi	r20, 0x01	; 1
 452:	60 ea       	ldi	r22, 0xA0	; 160
 454:	79 e0       	ldi	r23, 0x09	; 9
 456:	88 e2       	ldi	r24, 0x28	; 40
 458:	90 e2       	ldi	r25, 0x20	; 32
 45a:	0e 94 36 05 	call	0xa6c	; 0xa6c <USART_InterruptDriver_Initialize>
	
	/* USARTD0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(USART_data.usart, USART_CHSIZE_8BIT_gc,
 45e:	c0 91 28 20 	lds	r28, 0x2028
 462:	d0 91 29 20 	lds	r29, 0x2029
 466:	83 e0       	ldi	r24, 0x03	; 3
 468:	8d 83       	std	Y+5, r24	; 0x05
                     USART_PMODE_DISABLED_gc, false);

	/* Enable RXC interrupt. */
	USART_RxdInterruptLevel_Set(USART_data.usart, USART_RXCINTLVL_LO_gc);
 46a:	8b 81       	ldd	r24, Y+3	; 0x03
 46c:	8f 7c       	andi	r24, 0xCF	; 207
 46e:	80 61       	ori	r24, 0x10	; 16
 470:	8b 83       	std	Y+3, r24	; 0x03
	/* Set Baudrate to 9600 bps:
	 * Do not use the baudrate scale factor
	 * Baudrate ((I/O clock frequency)/(2^(ScaleFactor)*16*Baudrate))-1
	 */
	
	USART_Baudrate_Set(&USARTD0, ((F_CPU/(16*baudrate))-1) , 0);
 472:	80 91 01 20 	lds	r24, 0x2001
 476:	90 91 02 20 	lds	r25, 0x2002
 47a:	a0 91 03 20 	lds	r26, 0x2003
 47e:	b0 91 04 20 	lds	r27, 0x2004
 482:	88 0f       	add	r24, r24
 484:	99 1f       	adc	r25, r25
 486:	aa 1f       	adc	r26, r26
 488:	bb 1f       	adc	r27, r27
 48a:	88 0f       	add	r24, r24
 48c:	99 1f       	adc	r25, r25
 48e:	aa 1f       	adc	r26, r26
 490:	bb 1f       	adc	r27, r27
 492:	9c 01       	movw	r18, r24
 494:	ad 01       	movw	r20, r26
 496:	22 0f       	add	r18, r18
 498:	33 1f       	adc	r19, r19
 49a:	44 1f       	adc	r20, r20
 49c:	55 1f       	adc	r21, r21
 49e:	22 0f       	add	r18, r18
 4a0:	33 1f       	adc	r19, r19
 4a2:	44 1f       	adc	r20, r20
 4a4:	55 1f       	adc	r21, r21
 4a6:	60 e0       	ldi	r22, 0x00	; 0
 4a8:	78 e4       	ldi	r23, 0x48	; 72
 4aa:	88 ee       	ldi	r24, 0xE8	; 232
 4ac:	91 e0       	ldi	r25, 0x01	; 1
 4ae:	0e 94 a8 05 	call	0xb50	; 0xb50 <__udivmodsi4>
 4b2:	82 2f       	mov	r24, r18
 4b4:	81 50       	subi	r24, 0x01	; 1
 4b6:	e0 ea       	ldi	r30, 0xA0	; 160
 4b8:	f9 e0       	ldi	r31, 0x09	; 9
 4ba:	86 83       	std	Z+6, r24	; 0x06
 4bc:	da 01       	movw	r26, r20
 4be:	c9 01       	movw	r24, r18
 4c0:	01 97       	sbiw	r24, 0x01	; 1
 4c2:	a1 09       	sbc	r26, r1
 4c4:	b1 09       	sbc	r27, r1
 4c6:	89 2f       	mov	r24, r25
 4c8:	9a 2f       	mov	r25, r26
 4ca:	ab 2f       	mov	r26, r27
 4cc:	bb 27       	eor	r27, r27
 4ce:	87 83       	std	Z+7, r24	; 0x07
	
	//USART_Baudrate_Set(&USARTD0, 1/(16*((F_CPU/baudrate)-1)) , 0);

	/* Enable both RX and TX. */
	USART_Rx_Enable(USART_data.usart);
 4d0:	8c 81       	ldd	r24, Y+4	; 0x04
 4d2:	80 61       	ori	r24, 0x10	; 16
 4d4:	8c 83       	std	Y+4, r24	; 0x04
	USART_Tx_Enable(USART_data.usart);
 4d6:	8c 81       	ldd	r24, Y+4	; 0x04
 4d8:	88 60       	ori	r24, 0x08	; 8
 4da:	8c 83       	std	Y+4, r24	; 0x04


}
 4dc:	df 91       	pop	r29
 4de:	cf 91       	pop	r28
 4e0:	08 95       	ret

000004e2 <init_adc>:


void init_adc(void){
	ADCA.CTRLA = ADC_ENABLE_bm; //enable adc
 4e2:	e0 e0       	ldi	r30, 0x00	; 0
 4e4:	f2 e0       	ldi	r31, 0x02	; 2
 4e6:	81 e0       	ldi	r24, 0x01	; 1
 4e8:	80 83       	st	Z, r24
	ADCA.CTRLB = ADC_CONMODE_bm | ADC_RESOLUTION_12BIT_gc; //signed mode, no current limit, no freerun, 12 bit resolution
 4ea:	90 e1       	ldi	r25, 0x10	; 16
 4ec:	91 83       	std	Z+1, r25	; 0x01
	ADCA.PRESCALER = ADC_PRESCALER_DIV128_gc; //Set 32 clock devider
 4ee:	95 e0       	ldi	r25, 0x05	; 5
 4f0:	94 83       	std	Z+4, r25	; 0x04
	ADCA.REFCTRL = ADC_REFSEL_INT1V_gc; // use inernal 1V ref
 4f2:	12 82       	std	Z+2, r1	; 0x02
	
	ADCA.CH0.INTCTRL = ADC_CH_INTMODE_COMPLETE_gc|ADC_CH_INTLVL_LO_gc; //low priority interrupt on conv complete
 4f4:	82 a3       	std	Z+34, r24	; 0x22
 4f6:	08 95       	ret

000004f8 <__vector_47>:
//lookup table for RGB darlington
const uint8_t rgb_led_lut[8] PROGMEM = {
	0b000<<3, 0b100<<3 ,0b010<<3, 0b110<<3, 0b001<<3, 0b101<<3, 0b011<<3, 0b111<<3};


ISR(TCE0_OVF_vect){
 4f8:	1f 92       	push	r1
 4fa:	0f 92       	push	r0
 4fc:	0f b6       	in	r0, 0x3f	; 63
 4fe:	0f 92       	push	r0
 500:	11 24       	eor	r1, r1
 502:	0b b6       	in	r0, 0x3b	; 59
 504:	0f 92       	push	r0
 506:	2f 93       	push	r18
 508:	3f 93       	push	r19
 50a:	4f 93       	push	r20
 50c:	8f 93       	push	r24
 50e:	9f 93       	push	r25
 510:	af 93       	push	r26
 512:	bf 93       	push	r27
 514:	cf 93       	push	r28
 516:	df 93       	push	r29
 518:	ef 93       	push	r30
 51a:	ff 93       	push	r31
	static uint8_t led_multiplex_counter = 0; //software prescale
	static uint8_t led = 0; //next led number
	if(led_multiplex_counter++ > 0x5){
 51c:	80 91 06 20 	lds	r24, 0x2006
 520:	86 30       	cpi	r24, 0x06	; 6
 522:	20 f4       	brcc	.+8      	; 0x52c <__vector_47+0x34>
 524:	8f 5f       	subi	r24, 0xFF	; 255
 526:	80 93 06 20 	sts	0x2006, r24
 52a:	4c c0       	rjmp	.+152    	; 0x5c4 <__vector_47+0xcc>
		led_multiplex_counter=0;
 52c:	10 92 06 20 	sts	0x2006, r1
		//disable LED OUTPUT

		TCE0.CTRLA = 0; // disable timer
 530:	a0 e0       	ldi	r26, 0x00	; 0
 532:	ba e0       	ldi	r27, 0x0A	; 10
 534:	1c 92       	st	X, r1
		PORTE.OUTCLR = PIN0_bm | PIN1_bm | PIN2_bm; // clear outputs
 536:	87 e0       	ldi	r24, 0x07	; 7
 538:	e0 e8       	ldi	r30, 0x80	; 128
 53a:	f6 e0       	ldi	r31, 0x06	; 6
 53c:	86 83       	std	Z+6, r24	; 0x06

		//choose LED on multiplexer
		PORTF.OUTCLR = (0b111 << 3);
 53e:	c0 ea       	ldi	r28, 0xA0	; 160
 540:	d6 e0       	ldi	r29, 0x06	; 6
 542:	88 e3       	ldi	r24, 0x38	; 56
 544:	8e 83       	std	Y+6, r24	; 0x06
		PORTF.OUTSET = (pgm_read_word (&rgb_led_lut[led]));
 546:	40 91 07 20 	lds	r20, 0x2007
 54a:	84 2f       	mov	r24, r20
 54c:	90 e0       	ldi	r25, 0x00	; 0
 54e:	fc 01       	movw	r30, r24
 550:	e0 53       	subi	r30, 0x30	; 48
 552:	fe 4f       	sbci	r31, 0xFE	; 254
 554:	25 91       	lpm	r18, Z+
 556:	34 91       	lpm	r19, Z
 558:	2d 83       	std	Y+5, r18	; 0x05
  			
		//set pwm values
		PWM_RED = pgm_read_word (&pwmtable_12[myColors[led].red]);
 55a:	ec 01       	movw	r28, r24
 55c:	cc 0f       	add	r28, r28
 55e:	dd 1f       	adc	r29, r29
 560:	c8 0f       	add	r28, r24
 562:	d9 1f       	adc	r29, r25
 564:	c8 5f       	subi	r28, 0xF8	; 248
 566:	df 4d       	sbci	r29, 0xDF	; 223
 568:	e8 81       	ld	r30, Y
 56a:	f0 e0       	ldi	r31, 0x00	; 0
 56c:	ee 0f       	add	r30, r30
 56e:	ff 1f       	adc	r31, r31
 570:	e8 52       	subi	r30, 0x28	; 40
 572:	fe 4f       	sbci	r31, 0xFE	; 254
 574:	85 91       	lpm	r24, Z+
 576:	94 91       	lpm	r25, Z
 578:	9c 96       	adiw	r26, 0x2c	; 44
 57a:	8d 93       	st	X+, r24
 57c:	9c 93       	st	X, r25
 57e:	9d 97       	sbiw	r26, 0x2d	; 45
		PWM_GREEN = pgm_read_word(&pwmtable_12[myColors[led].green]);
 580:	e9 81       	ldd	r30, Y+1	; 0x01
 582:	f0 e0       	ldi	r31, 0x00	; 0
 584:	ee 0f       	add	r30, r30
 586:	ff 1f       	adc	r31, r31
 588:	e8 52       	subi	r30, 0x28	; 40
 58a:	fe 4f       	sbci	r31, 0xFE	; 254
 58c:	85 91       	lpm	r24, Z+
 58e:	94 91       	lpm	r25, Z
 590:	98 96       	adiw	r26, 0x28	; 40
 592:	8d 93       	st	X+, r24
 594:	9c 93       	st	X, r25
 596:	99 97       	sbiw	r26, 0x29	; 41
		PWM_BLUE = pgm_read_word (&pwmtable_12[myColors[led].blue]);
 598:	ea 81       	ldd	r30, Y+2	; 0x02
 59a:	f0 e0       	ldi	r31, 0x00	; 0
 59c:	ee 0f       	add	r30, r30
 59e:	ff 1f       	adc	r31, r31
 5a0:	e8 52       	subi	r30, 0x28	; 40
 5a2:	fe 4f       	sbci	r31, 0xFE	; 254
 5a4:	85 91       	lpm	r24, Z+
 5a6:	94 91       	lpm	r25, Z
 5a8:	9a 96       	adiw	r26, 0x2a	; 42
 5aa:	8d 93       	st	X+, r24
 5ac:	9c 93       	st	X, r25
 5ae:	9b 97       	sbiw	r26, 0x2b	; 43

		//reset counter
		TCE0.CNT = 0x00;
 5b0:	90 96       	adiw	r26, 0x20	; 32
 5b2:	1d 92       	st	X+, r1
 5b4:	1c 92       	st	X, r1
 5b6:	91 97       	sbiw	r26, 0x21	; 33
		//restart counter
		TCE0.CTRLA = TC_CLKSEL_DIV1_gc;
 5b8:	81 e0       	ldi	r24, 0x01	; 1
 5ba:	8c 93       	st	X, r24

		//select next LED
		led++;
 5bc:	4f 5f       	subi	r20, 0xFF	; 255
		led &= 0b111;
 5be:	47 70       	andi	r20, 0x07	; 7
 5c0:	40 93 07 20 	sts	0x2007, r20
	}
}
 5c4:	ff 91       	pop	r31
 5c6:	ef 91       	pop	r30
 5c8:	df 91       	pop	r29
 5ca:	cf 91       	pop	r28
 5cc:	bf 91       	pop	r27
 5ce:	af 91       	pop	r26
 5d0:	9f 91       	pop	r25
 5d2:	8f 91       	pop	r24
 5d4:	4f 91       	pop	r20
 5d6:	3f 91       	pop	r19
 5d8:	2f 91       	pop	r18
 5da:	0f 90       	pop	r0
 5dc:	0b be       	out	0x3b, r0	; 59
 5de:	0f 90       	pop	r0
 5e0:	0f be       	out	0x3f, r0	; 63
 5e2:	0f 90       	pop	r0
 5e4:	1f 90       	pop	r1
 5e6:	18 95       	reti

000005e8 <start_adc>:



void start_adc(uint8_t input){
	//input between 0 and 15
	ADCA.CH0.MUXCTRL = (input<<3) | ADC_CH_MUXNEG_PIN1_gc; //setup mux: input chanel | refference
 5e8:	28 e0       	ldi	r18, 0x08	; 8
 5ea:	82 9f       	mul	r24, r18
 5ec:	c0 01       	movw	r24, r0
 5ee:	11 24       	eor	r1, r1
 5f0:	81 60       	ori	r24, 0x01	; 1
 5f2:	e0 e0       	ldi	r30, 0x00	; 0
 5f4:	f2 e0       	ldi	r31, 0x02	; 2
 5f6:	81 a3       	std	Z+33, r24	; 0x21
	ADCA.CH0.CTRL = ADC_CH_START_bm | ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_DIFF_gc; //start conv with 1x gain, diff mode
 5f8:	82 e8       	ldi	r24, 0x82	; 130
 5fa:	80 a3       	std	Z+32, r24	; 0x20
 5fc:	08 95       	ret

000005fe <set_beepmotor_speed>:
}



void set_beepmotor_speed(motor_t motor, int8_t speed){
 5fe:	cf 93       	push	r28
 600:	df 93       	push	r29
 602:	c8 2f       	mov	r28, r24
 604:	d6 2f       	mov	r29, r22
	motor_op_mode_t op = motor_stop;
	
	if (speed<0){
 606:	66 23       	and	r22, r22
 608:	5c f4       	brge	.+22     	; 0x620 <set_beepmotor_speed+0x22>
		if(speed == INT8_MIN){
 60a:	60 38       	cpi	r22, 0x80	; 128
 60c:	11 f0       	breq	.+4      	; 0x612 <set_beepmotor_speed+0x14>
			speed = INT8_MAX;
		}else{
			speed = -speed;
 60e:	d1 95       	neg	r29
 610:	01 c0       	rjmp	.+2      	; 0x614 <set_beepmotor_speed+0x16>
void set_beepmotor_speed(motor_t motor, int8_t speed){
	motor_op_mode_t op = motor_stop;
	
	if (speed<0){
		if(speed == INT8_MIN){
			speed = INT8_MAX;
 612:	df e7       	ldi	r29, 0x7F	; 127
		}else{
			speed = -speed;
		}		
		if(motor == motor_l){
 614:	c4 30       	cpi	r28, 0x04	; 4
 616:	51 f0       	breq	.+20     	; 0x62c <set_beepmotor_speed+0x2e>
			op = motor_cw;
		}else if(motor == motor_r){
 618:	c6 30       	cpi	r28, 0x06	; 6
 61a:	51 f0       	breq	.+20     	; 0x630 <set_beepmotor_speed+0x32>
}



void set_beepmotor_speed(motor_t motor, int8_t speed){
	motor_op_mode_t op = motor_stop;
 61c:	63 e0       	ldi	r22, 0x03	; 3
 61e:	0d c0       	rjmp	.+26     	; 0x63a <set_beepmotor_speed+0x3c>
			op = motor_cw;
		}else if(motor == motor_r){
			op = motor_ccw;
		}
	}else{
		if(motor == motor_l){
 620:	84 30       	cpi	r24, 0x04	; 4
 622:	41 f0       	breq	.+16     	; 0x634 <set_beepmotor_speed+0x36>
			op = motor_ccw;
			}else if(motor == motor_r){
 624:	86 30       	cpi	r24, 0x06	; 6
 626:	41 f0       	breq	.+16     	; 0x638 <set_beepmotor_speed+0x3a>
}



void set_beepmotor_speed(motor_t motor, int8_t speed){
	motor_op_mode_t op = motor_stop;
 628:	63 e0       	ldi	r22, 0x03	; 3
 62a:	07 c0       	rjmp	.+14     	; 0x63a <set_beepmotor_speed+0x3c>
			speed = INT8_MAX;
		}else{
			speed = -speed;
		}		
		if(motor == motor_l){
			op = motor_cw;
 62c:	61 e0       	ldi	r22, 0x01	; 1
 62e:	05 c0       	rjmp	.+10     	; 0x63a <set_beepmotor_speed+0x3c>
		}else if(motor == motor_r){
			op = motor_ccw;
 630:	62 e0       	ldi	r22, 0x02	; 2
 632:	03 c0       	rjmp	.+6      	; 0x63a <set_beepmotor_speed+0x3c>
		}
	}else{
		if(motor == motor_l){
			op = motor_ccw;
 634:	62 e0       	ldi	r22, 0x02	; 2
 636:	01 c0       	rjmp	.+2      	; 0x63a <set_beepmotor_speed+0x3c>
			}else if(motor == motor_r){
			op = motor_cw;
 638:	61 e0       	ldi	r22, 0x01	; 1
		}
	}
	uint8_t new_speed = speed * (UINT8_MAX / INT8_MAX);
	set_motor_operation_mode(motor, op);
 63a:	8c 2f       	mov	r24, r28
 63c:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <set_motor_operation_mode>
			op = motor_ccw;
			}else if(motor == motor_r){
			op = motor_cw;
		}
	}
	uint8_t new_speed = speed * (UINT8_MAX / INT8_MAX);
 640:	6d 2f       	mov	r22, r29
 642:	66 0f       	add	r22, r22
	set_motor_operation_mode(motor, op);
	set_motor_speed(motor, new_speed);
 644:	8c 2f       	mov	r24, r28
 646:	0e 94 17 05 	call	0xa2e	; 0xa2e <set_motor_speed>
	
}
 64a:	df 91       	pop	r29
 64c:	cf 91       	pop	r28
 64e:	08 95       	ret

00000650 <main>:
const uint8_t ir_led_lut[8] PROGMEM = {
0b000,0b001,0b010,0b011,0b101,0b110,0b111,0b100};


int main(void)
{
 650:	cf 93       	push	r28
 652:	df 93       	push	r29
 654:	cd b7       	in	r28, 0x3d	; 61
 656:	de b7       	in	r29, 0x3e	; 62
 658:	28 97       	sbiw	r28, 0x08	; 8
 65a:	cd bf       	out	0x3d, r28	; 61
 65c:	de bf       	out	0x3e, r29	; 62
	static bool ready_for_RXdata = true;
	
	init_enable_32mhz();
 65e:	0e 94 0d 02 	call	0x41a	; 0x41a <init_enable_32mhz>
	init_usart();
 662:	0e 94 20 02 	call	0x440	; 0x440 <init_usart>
	init_motor();
 666:	0e 94 00 05 	call	0xa00	; 0xa00 <init_motor>
	init_adc();
 66a:	0e 94 71 02 	call	0x4e2	; 0x4e2 <init_adc>
	//TODO decide about priorities
	
}

inline void init_rgb_led(void){
	PORTF.DIRSET = PIN3_bm | PIN4_bm | PIN5_bm; //LED multiplexer Pins as output
 66e:	a0 ea       	ldi	r26, 0xA0	; 160
 670:	b6 e0       	ldi	r27, 0x06	; 6
 672:	88 e3       	ldi	r24, 0x38	; 56
 674:	11 96       	adiw	r26, 0x01	; 1
 676:	8c 93       	st	X, r24
 678:	11 97       	sbiw	r26, 0x01	; 1
	PORTE.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm; //Set LED PWM as output
 67a:	e0 e8       	ldi	r30, 0x80	; 128
 67c:	f6 e0       	ldi	r31, 0x06	; 6
 67e:	27 e0       	ldi	r18, 0x07	; 7
 680:	21 83       	std	Z+1, r18	; 0x01
	PORTE.PIN0CTRL |= PORT_INVEN_bm; //Invert PWM Channels for NAND driver
 682:	80 89       	ldd	r24, Z+16	; 0x10
 684:	80 64       	ori	r24, 0x40	; 64
 686:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL |= PORT_INVEN_bm;
 688:	81 89       	ldd	r24, Z+17	; 0x11
 68a:	80 64       	ori	r24, 0x40	; 64
 68c:	81 8b       	std	Z+17, r24	; 0x11
	PORTE.PIN2CTRL |= PORT_INVEN_bm;
 68e:	82 89       	ldd	r24, Z+18	; 0x12
 690:	80 64       	ori	r24, 0x40	; 64
 692:	82 8b       	std	Z+18, r24	; 0x12

	
 	TCE0.CTRLA = TC_CLKSEL_DIV1_gc; //prescaler: Clk/1
 694:	e0 e0       	ldi	r30, 0x00	; 0
 696:	fa e0       	ldi	r31, 0x0A	; 10
 698:	31 e0       	ldi	r19, 0x01	; 1
 69a:	30 83       	st	Z, r19
	
	TCE0.PER = 0xfff; //12 Bit resolution per period
 69c:	8f ef       	ldi	r24, 0xFF	; 255
 69e:	9f e0       	ldi	r25, 0x0F	; 15
 6a0:	86 a3       	std	Z+38, r24	; 0x26
 6a2:	97 a3       	std	Z+39, r25	; 0x27
	
	//Enable overflow interrupt for Timer 0 on Port C to swich rgb LED
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
 6a4:	36 83       	std	Z+6, r19	; 0x06
}


inline void enable_rgb_leds(bool enable){
	if (enable){
		TCE0.CTRLB = PWM_RED_ENABLE_gc|PWM_GREEN_ENABLE_gc|PWM_BLUE_ENABLE_gc| TC_WGMODE_SS_gc; //enable pwm output, Single slope pwm
 6a6:	83 e7       	ldi	r24, 0x73	; 115
 6a8:	81 83       	std	Z+1, r24	; 0x01
	init_rgb_led();
	enable_rgb_leds(true);
	

	/* Enable PMIC interrupt level low. */
	PMIC.CTRL |= PMIC_LOLVLEX_bm;
 6aa:	e0 ea       	ldi	r30, 0xA0	; 160
 6ac:	f0 e0       	ldi	r31, 0x00	; 0
 6ae:	82 81       	ldd	r24, Z+2	; 0x02
 6b0:	81 60       	ori	r24, 0x01	; 1
 6b2:	82 83       	std	Z+2, r24	; 0x02

	/* Enable global interrupts. */
	sei();
 6b4:	78 94       	sei

	// set some colors
	myColors[0].red = 0x00;
 6b6:	10 92 08 20 	sts	0x2008, r1
	myColors[0].green = 0x00;
 6ba:	10 92 09 20 	sts	0x2009, r1
	myColors[0].blue = 0x00;
 6be:	10 92 0a 20 	sts	0x200A, r1
	
	myColors[1].red = 0x00;
 6c2:	10 92 0b 20 	sts	0x200B, r1
	myColors[1].green = 0xff;
 6c6:	8f ef       	ldi	r24, 0xFF	; 255
 6c8:	80 93 0c 20 	sts	0x200C, r24
	myColors[1].blue = 0x00;
 6cc:	10 92 0d 20 	sts	0x200D, r1
	
	myColors[2].red = 0xff;
 6d0:	80 93 0e 20 	sts	0x200E, r24
	myColors[2].green = 0x00;
 6d4:	10 92 0f 20 	sts	0x200F, r1
	myColors[2].blue = 0x00;
 6d8:	10 92 10 20 	sts	0x2010, r1
	
	myColors[3].red = 0x00;
 6dc:	10 92 11 20 	sts	0x2011, r1
	myColors[3].green = 0x00;
 6e0:	10 92 12 20 	sts	0x2012, r1
	myColors[3].blue = 0x00;
 6e4:	10 92 13 20 	sts	0x2013, r1
	
	myColors[4].red = 0x00;
 6e8:	10 92 14 20 	sts	0x2014, r1
	myColors[4].green = 0x00;
 6ec:	10 92 15 20 	sts	0x2015, r1
	myColors[4].blue = 0x00;
 6f0:	10 92 16 20 	sts	0x2016, r1
	
	myColors[5].red = 0xff;
 6f4:	80 93 17 20 	sts	0x2017, r24
	myColors[5].green = 0xff;
 6f8:	80 93 18 20 	sts	0x2018, r24
	myColors[5].blue = 0x00;
 6fc:	10 92 19 20 	sts	0x2019, r1
	
	myColors[6].red = 0xff;
 700:	80 93 1a 20 	sts	0x201A, r24
	myColors[6].green = 0x00;
 704:	10 92 1b 20 	sts	0x201B, r1
	myColors[6].blue = 0xff;
 708:	80 93 1c 20 	sts	0x201C, r24
	
	myColors[7].red = 0x00;
 70c:	10 92 1d 20 	sts	0x201D, r1
	myColors[7].green = 0x00;
 710:	10 92 1e 20 	sts	0x201E, r1
	myColors[7].blue = 0x00;
 714:	10 92 1f 20 	sts	0x201F, r1
	next_command.head = 0;
	next_command.command = 0;
	next_command.device = 0;
	
	//TEMP IR LED TEST
	PORTF.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;
 718:	11 96       	adiw	r26, 0x01	; 1
 71a:	2c 93       	st	X, r18
 71c:	11 97       	sbiw	r26, 0x01	; 1
	PORTF.OUTSET = pgm_read_word(&ir_led_lut[2]);;
 71e:	ea ec       	ldi	r30, 0xCA	; 202
 720:	f1 e0       	ldi	r31, 0x01	; 1
 722:	85 91       	lpm	r24, Z+
 724:	94 91       	lpm	r25, Z
 726:	15 96       	adiw	r26, 0x05	; 5
 728:	8c 93       	st	X, r24

	Command_Buffer_t next_command;
	next_command.data_missing =- 1;
	next_command.head = 0;
	next_command.command = 0;
	next_command.device = 0;
 72a:	00 e0       	ldi	r16, 0x00	; 0
	// TODO Interrupts erst später aktivieren

	Command_Buffer_t next_command;
	next_command.data_missing =- 1;
	next_command.head = 0;
	next_command.command = 0;
 72c:	b1 2c       	mov	r11, r1
	//set_motor_on(true);
	// TODO Interrupts erst später aktivieren

	Command_Buffer_t next_command;
	next_command.data_missing =- 1;
	next_command.head = 0;
 72e:	a1 2c       	mov	r10, r1
	
	//set_motor_on(true);
	// TODO Interrupts erst später aktivieren

	Command_Buffer_t next_command;
	next_command.data_missing =- 1;
 730:	1f ef       	ldi	r17, 0xFF	; 255
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
						next_command.data_missing =- 1;
 732:	dd 24       	eor	r13, r13
 734:	da 94       	dec	r13
}


inline void enable_rgb_leds(bool enable){
	if (enable){
		TCE0.CTRLB = PWM_RED_ENABLE_gc|PWM_GREEN_ENABLE_gc|PWM_BLUE_ENABLE_gc| TC_WGMODE_SS_gc; //enable pwm output, Single slope pwm
 736:	0f 2e       	mov	r0, r31
 738:	e1 2c       	mov	r14, r1
 73a:	fa e0       	ldi	r31, 0x0A	; 10
 73c:	ff 2e       	mov	r15, r31
 73e:	f0 2d       	mov	r31, r0
 740:	0f 2e       	mov	r0, r31
 742:	f3 e7       	ldi	r31, 0x73	; 115
 744:	8f 2e       	mov	r8, r31
 746:	f0 2d       	mov	r31, r0
	}else{
		TCE0.CTRLB = 0; // disable pwm output
		PORTE.OUTCLR = PIN0_bm | PIN1_bm | PIN2_bm; // clear outputs
 748:	0f 2e       	mov	r0, r31
 74a:	f0 e8       	ldi	r31, 0x80	; 128
 74c:	6f 2e       	mov	r6, r31
 74e:	f6 e0       	ldi	r31, 0x06	; 6
 750:	7f 2e       	mov	r7, r31
 752:	f0 2d       	mov	r31, r0
 754:	0f 2e       	mov	r0, r31
 756:	f7 e0       	ldi	r31, 0x07	; 7
 758:	9f 2e       	mov	r9, r31
 75a:	f0 2d       	mov	r31, r0
							set_motor_on(false);
							//next_command.data_missing = -1;
						}
					}else if(next_command.device == beep_dev_ir){
						ready_for_RXdata = false;
						direct_send_adc_res = true;
 75c:	cc 24       	eor	r12, r12
 75e:	c3 94       	inc	r12
 760:	10 c0       	rjmp	.+32     	; 0x782 <main+0x132>
					next_command.device = data & beep_dev_mask;
					next_command.command = data & beep_command_mask;
					//get number of missing data to execute command
					if(next_command.device == beep_dev_motors){
						if(next_command.command == beep_com_left_motor){
							next_command.data_missing = 1;
 762:	1c 2d       	mov	r17, r12
 764:	0e c0       	rjmp	.+28     	; 0x782 <main+0x132>
						}else if (next_command.command == beep_com_right_motor){
							next_command.data_missing = 1;
 766:	1c 2d       	mov	r17, r12
 768:	0c c0       	rjmp	.+24     	; 0x782 <main+0x132>
						}else if (next_command.command == beep_com_both_motors){
							next_command.data_missing = 2;
 76a:	12 e0       	ldi	r17, 0x02	; 2
 76c:	0a c0       	rjmp	.+20     	; 0x782 <main+0x132>
						if(next_command.command == BEEP_COM_LEDS_OFF){
							enable_rgb_leds(false);
						}else if(next_command.command == BEEP_COM_LEDS_ON){
							enable_rgb_leds(true);
						}else if(next_command.command < 8){
							next_command.data_missing = 3;
 76e:	13 e0       	ldi	r17, 0x03	; 3
 770:	08 c0       	rjmp	.+16     	; 0x782 <main+0x132>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 772:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 774:	1d 2d       	mov	r17, r13
 776:	05 c0       	rjmp	.+10     	; 0x782 <main+0x132>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 778:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 77a:	1d 2d       	mov	r17, r13
 77c:	02 c0       	rjmp	.+4      	; 0x782 <main+0x132>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 77e:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 780:	1d 2d       	mov	r17, r13
	//TEMP IR LED TEST
	PORTF.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;
	PORTF.OUTSET = pgm_read_word(&ir_led_lut[2]);;
	
    while(1){		
		if(ready_for_RXdata){
 782:	80 91 05 20 	lds	r24, 0x2005
 786:	88 23       	and	r24, r24
 788:	09 f4       	brne	.+2      	; 0x78c <main+0x13c>
 78a:	99 c0       	rjmp	.+306    	; 0x8be <main+0x26e>
			if(USART_RXBufferData_Available(&USART_data)){
 78c:	88 e2       	ldi	r24, 0x28	; 40
 78e:	90 e2       	ldi	r25, 0x20	; 32
 790:	0e 94 65 05 	call	0xaca	; 0xaca <USART_RXBufferData_Available>
 794:	88 23       	and	r24, r24
 796:	a9 f3       	breq	.-22     	; 0x782 <main+0x132>
				uint8_t data = USART_RXBuffer_GetByte(&USART_data);
 798:	88 e2       	ldi	r24, 0x28	; 40
 79a:	90 e2       	ldi	r25, 0x20	; 32
 79c:	0e 94 6d 05 	call	0xada	; 0xada <USART_RXBuffer_GetByte>
				if(next_command.data_missing == -1){
 7a0:	1f 3f       	cpi	r17, 0xFF	; 255
 7a2:	09 f0       	breq	.+2      	; 0x7a6 <main+0x156>
 7a4:	43 c0       	rjmp	.+134    	; 0x82c <main+0x1dc>
					next_command.device = data & beep_dev_mask;
 7a6:	08 2f       	mov	r16, r24
 7a8:	00 7f       	andi	r16, 0xF0	; 240
					next_command.command = data & beep_command_mask;
 7aa:	0f 2e       	mov	r0, r31
 7ac:	ff e0       	ldi	r31, 0x0F	; 15
 7ae:	bf 2e       	mov	r11, r31
 7b0:	f0 2d       	mov	r31, r0
 7b2:	b8 22       	and	r11, r24
					//get number of missing data to execute command
					if(next_command.device == beep_dev_motors){
 7b4:	00 34       	cpi	r16, 0x40	; 64
 7b6:	b9 f4       	brne	.+46     	; 0x7e6 <main+0x196>
						if(next_command.command == beep_com_left_motor){
 7b8:	81 e0       	ldi	r24, 0x01	; 1
 7ba:	b8 16       	cp	r11, r24
 7bc:	91 f2       	breq	.-92     	; 0x762 <main+0x112>
							next_command.data_missing = 1;
						}else if (next_command.command == beep_com_right_motor){
 7be:	e2 e0       	ldi	r30, 0x02	; 2
 7c0:	be 16       	cp	r11, r30
 7c2:	89 f2       	breq	.-94     	; 0x766 <main+0x116>
							next_command.data_missing = 1;
						}else if (next_command.command == beep_com_both_motors){
 7c4:	f3 e0       	ldi	r31, 0x03	; 3
 7c6:	bf 16       	cp	r11, r31
 7c8:	81 f2       	breq	.-96     	; 0x76a <main+0x11a>
							next_command.data_missing = 2;
						}else if (next_command.command == beep_com_motor_enable){
 7ca:	8e e0       	ldi	r24, 0x0E	; 14
 7cc:	b8 12       	cpse	r11, r24
 7ce:	04 c0       	rjmp	.+8      	; 0x7d8 <main+0x188>
							set_motor_on(true);
 7d0:	8c 2d       	mov	r24, r12
 7d2:	0e 94 2a 05 	call	0xa54	; 0xa54 <set_motor_on>
 7d6:	d5 cf       	rjmp	.-86     	; 0x782 <main+0x132>
							//next_command.data_missing = -1;
						}else if (next_command.command == beep_com_motor_shutdown){
 7d8:	ef e0       	ldi	r30, 0x0F	; 15
 7da:	be 12       	cpse	r11, r30
 7dc:	d2 cf       	rjmp	.-92     	; 0x782 <main+0x132>
							set_motor_on(false);
 7de:	80 e0       	ldi	r24, 0x00	; 0
 7e0:	0e 94 2a 05 	call	0xa54	; 0xa54 <set_motor_on>
 7e4:	ce cf       	rjmp	.-100    	; 0x782 <main+0x132>
							//next_command.data_missing = -1;
						}
					}else if(next_command.device == beep_dev_ir){
 7e6:	01 11       	cpse	r16, r1
 7e8:	0b c0       	rjmp	.+22     	; 0x800 <main+0x1b0>
						ready_for_RXdata = false;
 7ea:	10 92 05 20 	sts	0x2005, r1
						direct_send_adc_res = true;
 7ee:	c0 92 00 20 	sts	0x2000, r12
						if(next_command.command <= 7){
 7f2:	f7 e0       	ldi	r31, 0x07	; 7
 7f4:	fb 15       	cp	r31, r11
 7f6:	28 f2       	brcs	.-118    	; 0x782 <main+0x132>
							start_adc(next_command.command);
 7f8:	8b 2d       	mov	r24, r11
 7fa:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <start_adc>
 7fe:	c1 cf       	rjmp	.-126    	; 0x782 <main+0x132>
						}else if (next_command.command == beep_com_ir_all){
							//TODO messe alle der reihe nach.
						}
					
						//next_command.data_missing = -1;
					}else if(next_command.device == BEEP_DEV_RGB_LED){
 800:	00 35       	cpi	r16, 0x50	; 80
 802:	09 f0       	breq	.+2      	; 0x806 <main+0x1b6>
 804:	be cf       	rjmp	.-132    	; 0x782 <main+0x132>
						if(next_command.command == BEEP_COM_LEDS_OFF){
 806:	8f e0       	ldi	r24, 0x0F	; 15
 808:	b8 12       	cpse	r11, r24
 80a:	05 c0       	rjmp	.+10     	; 0x816 <main+0x1c6>

inline void enable_rgb_leds(bool enable){
	if (enable){
		TCE0.CTRLB = PWM_RED_ENABLE_gc|PWM_GREEN_ENABLE_gc|PWM_BLUE_ENABLE_gc| TC_WGMODE_SS_gc; //enable pwm output, Single slope pwm
	}else{
		TCE0.CTRLB = 0; // disable pwm output
 80c:	f7 01       	movw	r30, r14
 80e:	11 82       	std	Z+1, r1	; 0x01
		PORTE.OUTCLR = PIN0_bm | PIN1_bm | PIN2_bm; // clear outputs
 810:	f3 01       	movw	r30, r6
 812:	96 82       	std	Z+6, r9	; 0x06
 814:	b6 cf       	rjmp	.-148    	; 0x782 <main+0x132>
					
						//next_command.data_missing = -1;
					}else if(next_command.device == BEEP_DEV_RGB_LED){
						if(next_command.command == BEEP_COM_LEDS_OFF){
							enable_rgb_leds(false);
						}else if(next_command.command == BEEP_COM_LEDS_ON){
 816:	fe e0       	ldi	r31, 0x0E	; 14
 818:	bf 12       	cpse	r11, r31
 81a:	03 c0       	rjmp	.+6      	; 0x822 <main+0x1d2>
}


inline void enable_rgb_leds(bool enable){
	if (enable){
		TCE0.CTRLB = PWM_RED_ENABLE_gc|PWM_GREEN_ENABLE_gc|PWM_BLUE_ENABLE_gc| TC_WGMODE_SS_gc; //enable pwm output, Single slope pwm
 81c:	f7 01       	movw	r30, r14
 81e:	81 82       	std	Z+1, r8	; 0x01
 820:	b0 cf       	rjmp	.-160    	; 0x782 <main+0x132>
					}else if(next_command.device == BEEP_DEV_RGB_LED){
						if(next_command.command == BEEP_COM_LEDS_OFF){
							enable_rgb_leds(false);
						}else if(next_command.command == BEEP_COM_LEDS_ON){
							enable_rgb_leds(true);
						}else if(next_command.command < 8){
 822:	f7 e0       	ldi	r31, 0x07	; 7
 824:	fb 15       	cp	r31, r11
 826:	08 f0       	brcs	.+2      	; 0x82a <main+0x1da>
 828:	a2 cf       	rjmp	.-188    	; 0x76e <main+0x11e>
 82a:	ab cf       	rjmp	.-170    	; 0x782 <main+0x132>
							next_command.data_missing = 3;
						}
					}
				}else{
					next_command.data[next_command.head] = data;
 82c:	e4 e0       	ldi	r30, 0x04	; 4
 82e:	f0 e0       	ldi	r31, 0x00	; 0
 830:	ec 0f       	add	r30, r28
 832:	fd 1f       	adc	r31, r29
 834:	ea 0d       	add	r30, r10
 836:	f1 1d       	adc	r31, r1
 838:	80 83       	st	Z, r24
					next_command.head += 1;
					next_command.data_missing -= 1;
 83a:	11 50       	subi	r17, 0x01	; 1
					if (next_command.data_missing == 0){					
 83c:	11 f0       	breq	.+4      	; 0x842 <main+0x1f2>
							next_command.data_missing = 3;
						}
					}
				}else{
					next_command.data[next_command.head] = data;
					next_command.head += 1;
 83e:	a3 94       	inc	r10
 840:	a0 cf       	rjmp	.-192    	; 0x782 <main+0x132>
					next_command.data_missing -= 1;
					if (next_command.data_missing == 0){					
						if(next_command.device==beep_dev_motors){
 842:	00 34       	cpi	r16, 0x40	; 64
 844:	11 f5       	brne	.+68     	; 0x88a <main+0x23a>
							if(next_command.command == beep_com_left_motor){
 846:	81 e0       	ldi	r24, 0x01	; 1
 848:	b8 12       	cpse	r11, r24
 84a:	07 c0       	rjmp	.+14     	; 0x85a <main+0x20a>
								set_beepmotor_speed(motor_l, next_command.data[0]);
 84c:	6c 81       	ldd	r22, Y+4	; 0x04
 84e:	84 e0       	ldi	r24, 0x04	; 4
 850:	0e 94 ff 02 	call	0x5fe	; 0x5fe <set_beepmotor_speed>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 854:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 856:	1d 2d       	mov	r17, r13
 858:	94 cf       	rjmp	.-216    	; 0x782 <main+0x132>
					next_command.data_missing -= 1;
					if (next_command.data_missing == 0){					
						if(next_command.device==beep_dev_motors){
							if(next_command.command == beep_com_left_motor){
								set_beepmotor_speed(motor_l, next_command.data[0]);
							}else if(next_command.command == beep_com_right_motor){
 85a:	e2 e0       	ldi	r30, 0x02	; 2
 85c:	be 12       	cpse	r11, r30
 85e:	07 c0       	rjmp	.+14     	; 0x86e <main+0x21e>
								set_beepmotor_speed(motor_r, next_command.data[0]);
 860:	6c 81       	ldd	r22, Y+4	; 0x04
 862:	86 e0       	ldi	r24, 0x06	; 6
 864:	0e 94 ff 02 	call	0x5fe	; 0x5fe <set_beepmotor_speed>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 868:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 86a:	1d 2d       	mov	r17, r13
 86c:	8a cf       	rjmp	.-236    	; 0x782 <main+0x132>
						if(next_command.device==beep_dev_motors){
							if(next_command.command == beep_com_left_motor){
								set_beepmotor_speed(motor_l, next_command.data[0]);
							}else if(next_command.command == beep_com_right_motor){
								set_beepmotor_speed(motor_r, next_command.data[0]);
							}else if(next_command.command == beep_com_both_motors){
 86e:	f3 e0       	ldi	r31, 0x03	; 3
 870:	bf 12       	cpse	r11, r31
 872:	7f cf       	rjmp	.-258    	; 0x772 <main+0x122>
								set_beepmotor_speed(motor_l, next_command.data[0]);
 874:	6c 81       	ldd	r22, Y+4	; 0x04
 876:	84 e0       	ldi	r24, 0x04	; 4
 878:	0e 94 ff 02 	call	0x5fe	; 0x5fe <set_beepmotor_speed>
								set_beepmotor_speed(motor_r, next_command.data[1]);
 87c:	6d 81       	ldd	r22, Y+5	; 0x05
 87e:	86 e0       	ldi	r24, 0x06	; 6
 880:	0e 94 ff 02 	call	0x5fe	; 0x5fe <set_beepmotor_speed>
								myColors[next_command.command].blue = next_command.data[2];
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 884:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 886:	1d 2d       	mov	r17, r13
 888:	7c cf       	rjmp	.-264    	; 0x782 <main+0x132>
								set_beepmotor_speed(motor_r, next_command.data[0]);
							}else if(next_command.command == beep_com_both_motors){
								set_beepmotor_speed(motor_l, next_command.data[0]);
								set_beepmotor_speed(motor_r, next_command.data[1]);
							}
						}else if(next_command.device == BEEP_DEV_RGB_LED){
 88a:	00 35       	cpi	r16, 0x50	; 80
 88c:	09 f0       	breq	.+2      	; 0x890 <main+0x240>
 88e:	74 cf       	rjmp	.-280    	; 0x778 <main+0x128>
							if (next_command.command < 8){
 890:	87 e0       	ldi	r24, 0x07	; 7
 892:	8b 15       	cp	r24, r11
 894:	08 f4       	brcc	.+2      	; 0x898 <main+0x248>
 896:	73 cf       	rjmp	.-282    	; 0x77e <main+0x12e>
								myColors[next_command.command].red = next_command.data[0];
 898:	2b 2d       	mov	r18, r11
 89a:	30 e0       	ldi	r19, 0x00	; 0
 89c:	8c 81       	ldd	r24, Y+4	; 0x04
 89e:	f9 01       	movw	r30, r18
 8a0:	ee 0f       	add	r30, r30
 8a2:	ff 1f       	adc	r31, r31
 8a4:	2e 0f       	add	r18, r30
 8a6:	3f 1f       	adc	r19, r31
 8a8:	f9 01       	movw	r30, r18
 8aa:	e8 5f       	subi	r30, 0xF8	; 248
 8ac:	ff 4d       	sbci	r31, 0xDF	; 223
 8ae:	80 83       	st	Z, r24
								myColors[next_command.command].green = next_command.data[1];
 8b0:	8d 81       	ldd	r24, Y+5	; 0x05
 8b2:	81 83       	std	Z+1, r24	; 0x01
								myColors[next_command.command].blue = next_command.data[2];
 8b4:	8e 81       	ldd	r24, Y+6	; 0x06
 8b6:	82 83       	std	Z+2, r24	; 0x02
							}
						}
					
						//command executed, prepare for new command
						next_command.head = 0;
 8b8:	a1 2c       	mov	r10, r1
						next_command.data_missing =- 1;
 8ba:	1d 2d       	mov	r17, r13
 8bc:	62 cf       	rjmp	.-316    	; 0x782 <main+0x132>
 8be:	ff cf       	rjmp	.-2      	; 0x8be <main+0x26e>

000008c0 <__vector_88>:
    }
}


ISR(USARTD0_RXC_vect)
{
 8c0:	1f 92       	push	r1
 8c2:	0f 92       	push	r0
 8c4:	0f b6       	in	r0, 0x3f	; 63
 8c6:	0f 92       	push	r0
 8c8:	11 24       	eor	r1, r1
 8ca:	0b b6       	in	r0, 0x3b	; 59
 8cc:	0f 92       	push	r0
 8ce:	2f 93       	push	r18
 8d0:	3f 93       	push	r19
 8d2:	4f 93       	push	r20
 8d4:	5f 93       	push	r21
 8d6:	6f 93       	push	r22
 8d8:	7f 93       	push	r23
 8da:	8f 93       	push	r24
 8dc:	9f 93       	push	r25
 8de:	af 93       	push	r26
 8e0:	bf 93       	push	r27
 8e2:	ef 93       	push	r30
 8e4:	ff 93       	push	r31
	USART_RXComplete(&USART_data);
 8e6:	88 e2       	ldi	r24, 0x28	; 40
 8e8:	90 e2       	ldi	r25, 0x20	; 32
 8ea:	0e 94 79 05 	call	0xaf2	; 0xaf2 <USART_RXComplete>
}
 8ee:	ff 91       	pop	r31
 8f0:	ef 91       	pop	r30
 8f2:	bf 91       	pop	r27
 8f4:	af 91       	pop	r26
 8f6:	9f 91       	pop	r25
 8f8:	8f 91       	pop	r24
 8fa:	7f 91       	pop	r23
 8fc:	6f 91       	pop	r22
 8fe:	5f 91       	pop	r21
 900:	4f 91       	pop	r20
 902:	3f 91       	pop	r19
 904:	2f 91       	pop	r18
 906:	0f 90       	pop	r0
 908:	0b be       	out	0x3b, r0	; 59
 90a:	0f 90       	pop	r0
 90c:	0f be       	out	0x3f, r0	; 63
 90e:	0f 90       	pop	r0
 910:	1f 90       	pop	r1
 912:	18 95       	reti

00000914 <__vector_89>:


ISR(USARTD0_DRE_vect)
{
 914:	1f 92       	push	r1
 916:	0f 92       	push	r0
 918:	0f b6       	in	r0, 0x3f	; 63
 91a:	0f 92       	push	r0
 91c:	11 24       	eor	r1, r1
 91e:	0b b6       	in	r0, 0x3b	; 59
 920:	0f 92       	push	r0
 922:	2f 93       	push	r18
 924:	3f 93       	push	r19
 926:	4f 93       	push	r20
 928:	5f 93       	push	r21
 92a:	6f 93       	push	r22
 92c:	7f 93       	push	r23
 92e:	8f 93       	push	r24
 930:	9f 93       	push	r25
 932:	af 93       	push	r26
 934:	bf 93       	push	r27
 936:	ef 93       	push	r30
 938:	ff 93       	push	r31
	USART_DataRegEmpty(&USART_data);
 93a:	88 e2       	ldi	r24, 0x28	; 40
 93c:	90 e2       	ldi	r25, 0x20	; 32
 93e:	0e 94 8e 05 	call	0xb1c	; 0xb1c <USART_DataRegEmpty>
}
 942:	ff 91       	pop	r31
 944:	ef 91       	pop	r30
 946:	bf 91       	pop	r27
 948:	af 91       	pop	r26
 94a:	9f 91       	pop	r25
 94c:	8f 91       	pop	r24
 94e:	7f 91       	pop	r23
 950:	6f 91       	pop	r22
 952:	5f 91       	pop	r21
 954:	4f 91       	pop	r20
 956:	3f 91       	pop	r19
 958:	2f 91       	pop	r18
 95a:	0f 90       	pop	r0
 95c:	0b be       	out	0x3b, r0	; 59
 95e:	0f 90       	pop	r0
 960:	0f be       	out	0x3f, r0	; 63
 962:	0f 90       	pop	r0
 964:	1f 90       	pop	r1
 966:	18 95       	reti

00000968 <__vector_71>:

ISR(ADCA_CH0_vect){
 968:	1f 92       	push	r1
 96a:	0f 92       	push	r0
 96c:	0f b6       	in	r0, 0x3f	; 63
 96e:	0f 92       	push	r0
 970:	11 24       	eor	r1, r1
 972:	0b b6       	in	r0, 0x3b	; 59
 974:	0f 92       	push	r0
 976:	2f 93       	push	r18
 978:	3f 93       	push	r19
 97a:	4f 93       	push	r20
 97c:	5f 93       	push	r21
 97e:	6f 93       	push	r22
 980:	7f 93       	push	r23
 982:	8f 93       	push	r24
 984:	9f 93       	push	r25
 986:	af 93       	push	r26
 988:	bf 93       	push	r27
 98a:	ef 93       	push	r30
 98c:	ff 93       	push	r31
	if(direct_send_adc_res){
 98e:	80 91 00 20 	lds	r24, 0x2000
 992:	88 23       	and	r24, r24
 994:	71 f0       	breq	.+28     	; 0x9b2 <__vector_71+0x4a>
		USART_TXBuffer_PutByte(&USART_data, ADCA.CH0.RES / (2047 / 255));
 996:	e0 e0       	ldi	r30, 0x00	; 0
 998:	f2 e0       	ldi	r31, 0x02	; 2
 99a:	64 a1       	ldd	r22, Z+36	; 0x24
 99c:	75 a1       	ldd	r23, Z+37	; 0x25
 99e:	76 95       	lsr	r23
 9a0:	67 95       	ror	r22
 9a2:	76 95       	lsr	r23
 9a4:	67 95       	ror	r22
 9a6:	76 95       	lsr	r23
 9a8:	67 95       	ror	r22
 9aa:	88 e2       	ldi	r24, 0x28	; 40
 9ac:	90 e2       	ldi	r25, 0x20	; 32
 9ae:	0e 94 49 05 	call	0xa92	; 0xa92 <USART_TXBuffer_PutByte>
	}
}
 9b2:	ff 91       	pop	r31
 9b4:	ef 91       	pop	r30
 9b6:	bf 91       	pop	r27
 9b8:	af 91       	pop	r26
 9ba:	9f 91       	pop	r25
 9bc:	8f 91       	pop	r24
 9be:	7f 91       	pop	r23
 9c0:	6f 91       	pop	r22
 9c2:	5f 91       	pop	r21
 9c4:	4f 91       	pop	r20
 9c6:	3f 91       	pop	r19
 9c8:	2f 91       	pop	r18
 9ca:	0f 90       	pop	r0
 9cc:	0b be       	out	0x3b, r0	; 59
 9ce:	0f 90       	pop	r0
 9d0:	0f be       	out	0x3f, r0	; 63
 9d2:	0f 90       	pop	r0
 9d4:	1f 90       	pop	r1
 9d6:	18 95       	reti

000009d8 <set_motor_operation_mode>:
#include "motor_driver.h"

void set_motor_operation_mode(motor_t motor, motor_op_mode_t op){
	PORTE.OUTCLR = 0b11 << motor;
 9d8:	23 e0       	ldi	r18, 0x03	; 3
 9da:	30 e0       	ldi	r19, 0x00	; 0
 9dc:	08 2e       	mov	r0, r24
 9de:	02 c0       	rjmp	.+4      	; 0x9e4 <set_motor_operation_mode+0xc>
 9e0:	22 0f       	add	r18, r18
 9e2:	33 1f       	adc	r19, r19
 9e4:	0a 94       	dec	r0
 9e6:	e2 f7       	brpl	.-8      	; 0x9e0 <set_motor_operation_mode+0x8>
 9e8:	e0 e8       	ldi	r30, 0x80	; 128
 9ea:	f6 e0       	ldi	r31, 0x06	; 6
 9ec:	26 83       	std	Z+6, r18	; 0x06
	PORTE.OUTSET = op << motor;
 9ee:	70 e0       	ldi	r23, 0x00	; 0
 9f0:	9b 01       	movw	r18, r22
 9f2:	02 c0       	rjmp	.+4      	; 0x9f8 <set_motor_operation_mode+0x20>
 9f4:	22 0f       	add	r18, r18
 9f6:	33 1f       	adc	r19, r19
 9f8:	8a 95       	dec	r24
 9fa:	e2 f7       	brpl	.-8      	; 0x9f4 <set_motor_operation_mode+0x1c>
 9fc:	25 83       	std	Z+5, r18	; 0x05
 9fe:	08 95       	ret

00000a00 <init_motor>:
}

void init_motor(void){
 	PORTE.DIRSET = PIN4_bm | PIN5_bm | PIN6_bm | PIN7_bm; //Set Motor control as output
 a00:	80 ef       	ldi	r24, 0xF0	; 240
 a02:	e0 e8       	ldi	r30, 0x80	; 128
 a04:	f6 e0       	ldi	r31, 0x06	; 6
 a06:	81 83       	std	Z+1, r24	; 0x01
 	PORTA.DIRSET = PIN6_bm; // Standby as output
 a08:	80 e4       	ldi	r24, 0x40	; 64
 a0a:	e0 e0       	ldi	r30, 0x00	; 0
 a0c:	f6 e0       	ldi	r31, 0x06	; 6
 a0e:	81 83       	std	Z+1, r24	; 0x01
 	PORTC.DIRSET = PIN2_bm | PIN3_bm; //PWM as output
 a10:	8c e0       	ldi	r24, 0x0C	; 12
 a12:	e0 e4       	ldi	r30, 0x40	; 64
 a14:	f6 e0       	ldi	r31, 0x06	; 6
 a16:	81 83       	std	Z+1, r24	; 0x01
 	
 	TCC0.CTRLA = TC_CLKSEL_DIV1_gc; //prescaler: Clk/1
 a18:	e0 e0       	ldi	r30, 0x00	; 0
 a1a:	f8 e0       	ldi	r31, 0x08	; 8
 a1c:	81 e0       	ldi	r24, 0x01	; 1
 a1e:	80 83       	st	Z, r24
 	TCC0.CTRLB = TC0_CCCEN_bm|TC0_CCDEN_bm| TC_WGMODE_SS_gc; //enable pwm output, Single slope pwm
 a20:	83 ec       	ldi	r24, 0xC3	; 195
 a22:	81 83       	std	Z+1, r24	; 0x01
 	
 	TCC0.PER = 0xff;
 a24:	8f ef       	ldi	r24, 0xFF	; 255
 a26:	90 e0       	ldi	r25, 0x00	; 0
 a28:	86 a3       	std	Z+38, r24	; 0x26
 a2a:	97 a3       	std	Z+39, r25	; 0x27
 a2c:	08 95       	ret

00000a2e <set_motor_speed>:
	

}

void set_motor_speed(motor_t motor, uint8_t speed){
 a2e:	6b 3a       	cpi	r22, 0xAB	; 171
 a30:	08 f0       	brcs	.+2      	; 0xa34 <set_motor_speed+0x6>
 a32:	6a ea       	ldi	r22, 0xAA	; 170
	if(speed > 0xaa){//ensure 5V average
		speed = 0xaa;
	}
	
	if(motor == motor_l){
 a34:	84 30       	cpi	r24, 0x04	; 4
 a36:	31 f4       	brne	.+12     	; 0xa44 <set_motor_speed+0x16>
		TCC0.CCD = speed;
 a38:	70 e0       	ldi	r23, 0x00	; 0
 a3a:	e0 e0       	ldi	r30, 0x00	; 0
 a3c:	f8 e0       	ldi	r31, 0x08	; 8
 a3e:	66 a7       	std	Z+46, r22	; 0x2e
 a40:	77 a7       	std	Z+47, r23	; 0x2f
 a42:	08 95       	ret
	} else if(motor == motor_r){
 a44:	86 30       	cpi	r24, 0x06	; 6
 a46:	29 f4       	brne	.+10     	; 0xa52 <set_motor_speed+0x24>
		TCC0.CCC = speed;
 a48:	70 e0       	ldi	r23, 0x00	; 0
 a4a:	e0 e0       	ldi	r30, 0x00	; 0
 a4c:	f8 e0       	ldi	r31, 0x08	; 8
 a4e:	64 a7       	std	Z+44, r22	; 0x2c
 a50:	75 a7       	std	Z+45, r23	; 0x2d
 a52:	08 95       	ret

00000a54 <set_motor_on>:
	}
}

void set_motor_on(bool b){
	if(b){
 a54:	88 23       	and	r24, r24
 a56:	29 f0       	breq	.+10     	; 0xa62 <set_motor_on+0xe>
		PORTA.OUTSET = PIN6_bm;
 a58:	80 e4       	ldi	r24, 0x40	; 64
 a5a:	e0 e0       	ldi	r30, 0x00	; 0
 a5c:	f6 e0       	ldi	r31, 0x06	; 6
 a5e:	85 83       	std	Z+5, r24	; 0x05
 a60:	08 95       	ret
		}else{
		PORTA.OUTCLR = PIN6_bm;
 a62:	80 e4       	ldi	r24, 0x40	; 64
 a64:	e0 e0       	ldi	r30, 0x00	; 0
 a66:	f6 e0       	ldi	r31, 0x06	; 6
 a68:	86 83       	std	Z+6, r24	; 0x06
 a6a:	08 95       	ret

00000a6c <USART_InterruptDriver_Initialize>:
 *  \param dreIntLevel          Data register empty interrupt level.
 */
void USART_InterruptDriver_Initialize(USART_data_t * usart_data,
                                      USART_t * usart,
                                      USART_DREINTLVL_t dreIntLevel)
{
 a6c:	fc 01       	movw	r30, r24
	usart_data->usart = usart;
 a6e:	60 83       	st	Z, r22
 a70:	71 83       	std	Z+1, r23	; 0x01
	usart_data->dreIntLevel = dreIntLevel;
 a72:	42 83       	std	Z+2, r20	; 0x02

	usart_data->buffer.RX_Tail = 0;
 a74:	14 86       	std	Z+12, r1	; 0x0c
	usart_data->buffer.RX_Head = 0;
 a76:	13 86       	std	Z+11, r1	; 0x0b
	usart_data->buffer.TX_Tail = 0;
 a78:	16 86       	std	Z+14, r1	; 0x0e
	usart_data->buffer.TX_Head = 0;
 a7a:	15 86       	std	Z+13, r1	; 0x0d
 a7c:	08 95       	ret

00000a7e <USART_TXBuffer_FreeSpace>:
 *  \retval false     The receive buffer is empty.
 */
bool USART_TXBuffer_FreeSpace(USART_data_t * usart_data)
{
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = (usart_data->buffer.TX_Head + 1) & USART_TX_BUFFER_MASK;
 a7e:	fc 01       	movw	r30, r24
 a80:	25 85       	ldd	r18, Z+13	; 0x0d
	uint8_t tempTail = usart_data->buffer.TX_Tail;
 a82:	96 85       	ldd	r25, Z+14	; 0x0e
 *  \retval false     The receive buffer is empty.
 */
bool USART_TXBuffer_FreeSpace(USART_data_t * usart_data)
{
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = (usart_data->buffer.TX_Head + 1) & USART_TX_BUFFER_MASK;
 a84:	2f 5f       	subi	r18, 0xFF	; 255
 a86:	23 70       	andi	r18, 0x03	; 3
	uint8_t tempTail = usart_data->buffer.TX_Tail;

	/* There are data left in the buffer unless Head and Tail are equal. */
	return (tempHead != tempTail);
 a88:	81 e0       	ldi	r24, 0x01	; 1
 a8a:	29 13       	cpse	r18, r25
 a8c:	01 c0       	rjmp	.+2      	; 0xa90 <USART_TXBuffer_FreeSpace+0x12>
 a8e:	80 e0       	ldi	r24, 0x00	; 0
}
 a90:	08 95       	ret

00000a92 <USART_TXBuffer_PutByte>:
 *
 *  \param usart_data The USART_data_t struct instance.
 *  \param data       The data to send.
 */
bool USART_TXBuffer_PutByte(USART_data_t * usart_data, uint8_t data)
{
 a92:	1f 93       	push	r17
 a94:	cf 93       	push	r28
 a96:	df 93       	push	r29
 a98:	ec 01       	movw	r28, r24
 a9a:	16 2f       	mov	r17, r22
	uint8_t tempTX_Head;
	bool TXBuffer_FreeSpace;
	USART_Buffer_t * TXbufPtr;

	TXbufPtr = &usart_data->buffer;
	TXBuffer_FreeSpace = USART_TXBuffer_FreeSpace(usart_data);
 a9c:	0e 94 3f 05 	call	0xa7e	; 0xa7e <USART_TXBuffer_FreeSpace>


	if(TXBuffer_FreeSpace)
 aa0:	88 23       	and	r24, r24
 aa2:	79 f0       	breq	.+30     	; 0xac2 <USART_TXBuffer_PutByte+0x30>
	{
	  	tempTX_Head = TXbufPtr->TX_Head;
 aa4:	9d 85       	ldd	r25, Y+13	; 0x0d
	  	TXbufPtr->TX[tempTX_Head]= data;
 aa6:	fe 01       	movw	r30, r28
 aa8:	e9 0f       	add	r30, r25
 aaa:	f1 1d       	adc	r31, r1
 aac:	17 83       	std	Z+7, r17	; 0x07
		/* Advance buffer head. */
		TXbufPtr->TX_Head = (tempTX_Head + 1) & USART_TX_BUFFER_MASK;
 aae:	9f 5f       	subi	r25, 0xFF	; 255
 ab0:	93 70       	andi	r25, 0x03	; 3
 ab2:	9d 87       	std	Y+13, r25	; 0x0d

		/* Enable DRE interrupt. */
		tempCTRLA = usart_data->usart->CTRLA;
 ab4:	e8 81       	ld	r30, Y
 ab6:	f9 81       	ldd	r31, Y+1	; 0x01
 ab8:	93 81       	ldd	r25, Z+3	; 0x03
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | usart_data->dreIntLevel;
 aba:	9c 7f       	andi	r25, 0xFC	; 252
 abc:	2a 81       	ldd	r18, Y+2	; 0x02
 abe:	92 2b       	or	r25, r18
		usart_data->usart->CTRLA = tempCTRLA;
 ac0:	93 83       	std	Z+3, r25	; 0x03
	}
	return TXBuffer_FreeSpace;
}
 ac2:	df 91       	pop	r29
 ac4:	cf 91       	pop	r28
 ac6:	1f 91       	pop	r17
 ac8:	08 95       	ret

00000aca <USART_RXBufferData_Available>:
 *  \retval false     The receive buffer is empty.
 */
bool USART_RXBufferData_Available(USART_data_t * usart_data)
{
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = usart_data->buffer.RX_Head;
 aca:	fc 01       	movw	r30, r24
 acc:	23 85       	ldd	r18, Z+11	; 0x0b
	uint8_t tempTail = usart_data->buffer.RX_Tail;
 ace:	94 85       	ldd	r25, Z+12	; 0x0c

	/* There are data left in the buffer unless Head and Tail are equal. */
	return (tempHead != tempTail);
 ad0:	81 e0       	ldi	r24, 0x01	; 1
 ad2:	29 13       	cpse	r18, r25
 ad4:	01 c0       	rjmp	.+2      	; 0xad8 <USART_RXBufferData_Available+0xe>
 ad6:	80 e0       	ldi	r24, 0x00	; 0
}
 ad8:	08 95       	ret

00000ada <USART_RXBuffer_GetByte>:
 *  \param usart_data       The USART_data_t struct instance.
 *
 *  \return         Received data.
 */
uint8_t USART_RXBuffer_GetByte(USART_data_t * usart_data)
{
 ada:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	uint8_t ans;

	bufPtr = &usart_data->buffer;
	ans = (bufPtr->RX[bufPtr->RX_Tail]);
 adc:	84 85       	ldd	r24, Z+12	; 0x0c
 ade:	df 01       	movw	r26, r30
 ae0:	a8 0f       	add	r26, r24
 ae2:	b1 1d       	adc	r27, r1
 ae4:	13 96       	adiw	r26, 0x03	; 3
 ae6:	8c 91       	ld	r24, X

	/* Advance buffer tail. */
	bufPtr->RX_Tail = (bufPtr->RX_Tail + 1) & USART_RX_BUFFER_MASK;
 ae8:	94 85       	ldd	r25, Z+12	; 0x0c
 aea:	9f 5f       	subi	r25, 0xFF	; 255
 aec:	93 70       	andi	r25, 0x03	; 3
 aee:	94 87       	std	Z+12, r25	; 0x0c

	return ans;
}
 af0:	08 95       	ret

00000af2 <USART_RXComplete>:
 *  Stores received data in RX software buffer.
 *
 *  \param usart_data      The USART_data_t struct instance.
 */
bool USART_RXComplete(USART_data_t * usart_data)
{
 af2:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	bool ans;

	bufPtr = &usart_data->buffer;
	/* Advance buffer head. */
	uint8_t tempRX_Head = (bufPtr->RX_Head + 1) & USART_RX_BUFFER_MASK;
 af4:	83 85       	ldd	r24, Z+11	; 0x0b
 af6:	8f 5f       	subi	r24, 0xFF	; 255
 af8:	83 70       	andi	r24, 0x03	; 3

	/* Check for overflow. */
	uint8_t tempRX_Tail = bufPtr->RX_Tail;
 afa:	94 85       	ldd	r25, Z+12	; 0x0c
	uint8_t data = usart_data->usart->DATA;
 afc:	a0 81       	ld	r26, Z
 afe:	b1 81       	ldd	r27, Z+1	; 0x01
 b00:	2c 91       	ld	r18, X

	if (tempRX_Head == tempRX_Tail) {
 b02:	89 17       	cp	r24, r25
 b04:	49 f0       	breq	.+18     	; 0xb18 <USART_RXComplete+0x26>
	  	ans = false;
	}else{
		ans = true;
		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
 b06:	93 85       	ldd	r25, Z+11	; 0x0b
 b08:	df 01       	movw	r26, r30
 b0a:	a9 0f       	add	r26, r25
 b0c:	b1 1d       	adc	r27, r1
 b0e:	13 96       	adiw	r26, 0x03	; 3
 b10:	2c 93       	st	X, r18
		usart_data->buffer.RX_Head = tempRX_Head;
 b12:	83 87       	std	Z+11, r24	; 0x0b
	uint8_t data = usart_data->usart->DATA;

	if (tempRX_Head == tempRX_Tail) {
	  	ans = false;
	}else{
		ans = true;
 b14:	81 e0       	ldi	r24, 0x01	; 1
 b16:	08 95       	ret
	/* Check for overflow. */
	uint8_t tempRX_Tail = bufPtr->RX_Tail;
	uint8_t data = usart_data->usart->DATA;

	if (tempRX_Head == tempRX_Tail) {
	  	ans = false;
 b18:	80 e0       	ldi	r24, 0x00	; 0
		ans = true;
		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
		usart_data->buffer.RX_Head = tempRX_Head;
	}
	return ans;
}
 b1a:	08 95       	ret

00000b1c <USART_DataRegEmpty>:
 *  is empty. Argument is pointer to USART (USART_data_t).
 *
 *  \param usart_data      The USART_data_t struct instance.
 */
void USART_DataRegEmpty(USART_data_t * usart_data)
{
 b1c:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	bufPtr = &usart_data->buffer;

	/* Check if all data is transmitted. */
	uint8_t tempTX_Tail = usart_data->buffer.TX_Tail;
 b1e:	86 85       	ldd	r24, Z+14	; 0x0e
	if (bufPtr->TX_Head == tempTX_Tail){
 b20:	95 85       	ldd	r25, Z+13	; 0x0d
 b22:	98 13       	cpse	r25, r24
 b24:	07 c0       	rjmp	.+14     	; 0xb34 <USART_DataRegEmpty+0x18>
	    /* Disable DRE interrupts. */
		uint8_t tempCTRLA = usart_data->usart->CTRLA;
 b26:	01 90       	ld	r0, Z+
 b28:	f0 81       	ld	r31, Z
 b2a:	e0 2d       	mov	r30, r0
 b2c:	83 81       	ldd	r24, Z+3	; 0x03
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
 b2e:	8c 7f       	andi	r24, 0xFC	; 252
		usart_data->usart->CTRLA = tempCTRLA;
 b30:	83 83       	std	Z+3, r24	; 0x03
 b32:	08 95       	ret

	}else{
		/* Start transmitting. */
		uint8_t data = bufPtr->TX[usart_data->buffer.TX_Tail];
 b34:	86 85       	ldd	r24, Z+14	; 0x0e
 b36:	df 01       	movw	r26, r30
 b38:	a8 0f       	add	r26, r24
 b3a:	b1 1d       	adc	r27, r1
 b3c:	17 96       	adiw	r26, 0x07	; 7
 b3e:	8c 91       	ld	r24, X
		usart_data->usart->DATA = data;
 b40:	a0 81       	ld	r26, Z
 b42:	b1 81       	ldd	r27, Z+1	; 0x01
 b44:	8c 93       	st	X, r24

		/* Advance buffer tail. */
		bufPtr->TX_Tail = (bufPtr->TX_Tail + 1) & USART_TX_BUFFER_MASK;
 b46:	86 85       	ldd	r24, Z+14	; 0x0e
 b48:	8f 5f       	subi	r24, 0xFF	; 255
 b4a:	83 70       	andi	r24, 0x03	; 3
 b4c:	86 87       	std	Z+14, r24	; 0x0e
 b4e:	08 95       	ret

00000b50 <__udivmodsi4>:
 b50:	a1 e2       	ldi	r26, 0x21	; 33
 b52:	1a 2e       	mov	r1, r26
 b54:	aa 1b       	sub	r26, r26
 b56:	bb 1b       	sub	r27, r27
 b58:	fd 01       	movw	r30, r26
 b5a:	0d c0       	rjmp	.+26     	; 0xb76 <__udivmodsi4_ep>

00000b5c <__udivmodsi4_loop>:
 b5c:	aa 1f       	adc	r26, r26
 b5e:	bb 1f       	adc	r27, r27
 b60:	ee 1f       	adc	r30, r30
 b62:	ff 1f       	adc	r31, r31
 b64:	a2 17       	cp	r26, r18
 b66:	b3 07       	cpc	r27, r19
 b68:	e4 07       	cpc	r30, r20
 b6a:	f5 07       	cpc	r31, r21
 b6c:	20 f0       	brcs	.+8      	; 0xb76 <__udivmodsi4_ep>
 b6e:	a2 1b       	sub	r26, r18
 b70:	b3 0b       	sbc	r27, r19
 b72:	e4 0b       	sbc	r30, r20
 b74:	f5 0b       	sbc	r31, r21

00000b76 <__udivmodsi4_ep>:
 b76:	66 1f       	adc	r22, r22
 b78:	77 1f       	adc	r23, r23
 b7a:	88 1f       	adc	r24, r24
 b7c:	99 1f       	adc	r25, r25
 b7e:	1a 94       	dec	r1
 b80:	69 f7       	brne	.-38     	; 0xb5c <__udivmodsi4_loop>
 b82:	60 95       	com	r22
 b84:	70 95       	com	r23
 b86:	80 95       	com	r24
 b88:	90 95       	com	r25
 b8a:	9b 01       	movw	r18, r22
 b8c:	ac 01       	movw	r20, r24
 b8e:	bd 01       	movw	r22, r26
 b90:	cf 01       	movw	r24, r30
 b92:	08 95       	ret

00000b94 <_exit>:
 b94:	f8 94       	cli

00000b96 <__stop_program>:
 b96:	ff cf       	rjmp	.-2      	; 0xb96 <__stop_program>
